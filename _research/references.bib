@inproceedings{a,
abstract = {Dynamically typed programming languages are powerful tools for rapid software development. However, there are scenarios that would benefit from actual type information being available---e. g., code generation and optimisation as well as program comprehension. Since code written in such languages usually makes little or no explicit assumptions about types, type inference is not particularly well suited to obtain the desired information. This paper introduces type harvesting</i>, a practical approach to obtaining type information. It is based on stepwise code execution of the code in question, closely observing the types of entities in question. Type harvesting allows for exploiting unit tests to automatically obtain type information for a code base. The approach has been implemented in Squeak/Smalltalk. Its evaluation, using several complex applications, shows that type harvesting yields excellent results with high precision.},
author = {Haupt, Michael and Perscheid, M and Hirschfeld, R},
booktitle = {\ldots of the 2011 ACM Symposium on \ldots},
doi = {http://doi.acm.org/10.1145/1982185.1982464},
isbn = {9781450301138},
keywords = {Squeak,dynamic analysis,dynamically typed programming languages,type harvesting,type inference,unit tests},
mendeley-tags = {Squeak},
pages = {1282--1289},
title = {{Type harvesting: a practical approach to obtaining typing information in dynamic programming languages}},
url = {http://dl.acm.org/citation.cfm?id=1982464},
year = {2011}
}
@inproceedings{bergel_prototyping_2006,
author = {Bergel, Alexandre and Denker, Marcus},
booktitle = {\{ECOOP\}'06 \{Workshop\} on \{Revival\} of \{Dynamic\} \{Languages\}},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Prototyping Languages, Related Constructs and Tools with Squeak.}},
url = {https://hal.inria.fr/inria-00555724/},
year = {2006}
}
@inproceedings{nierstrasza_towards_2005,
abstract = {Not all unit tests are alike. Some tests are simple$\backslash$none-liners, while others contain a battery of$\backslash$nassertions. Certain tests focus on a single method,$\backslash$nwhile others test interactions between methods.$\backslash$nThere are even tests that do not contain assertions$\backslash$nat all. This can make it difficult for a developer$\backslash$nto understand which methods are tested by which$\backslash$ntests, to what degree they are tested, and what to$\backslash$ntake into account while refactoring. We have$\backslash$nmanually analyzed the test base of a large existing$\backslash$nobject-oriented system in order to derive a first$\backslash$ntaxonomy of unit tests. We have then developed some$\backslash$nsimple tools to semi-automatically categorize tests$\backslash$naccording to this taxonomy, and applied it to two$\backslash$ncase studies. Beside explaining our taxonomy, we$\backslash$nreport on our initial results using it, namely that$\backslash$na majority of unit tests focus on single methods and$\backslash$nthat our lightweight automatic categorization could$\backslash$nalready classify more than 50\% of these single$\backslash$nmethod commands.},
author = {Gaelli, Markus and Lanza, Michele and Nierstrasz, Oscar},
booktitle = {13th International European Smalltalk Conference (ESUG 2005)},
keywords = {13th international european smalltalk,Squeak,conference,conferences,esug,esug 2005,http,mustinclude,org,reverse engineering,smalltalk,taxonomy,thirteenthinternationalconference2005,unit testing,www},
mendeley-tags = {Squeak},
pages = {1--22},
publisher = {University of Bern, Switzerland},
title = {{Towards a taxonomy of SUnit tests}},
url = {http://www.old.inf.usi.ch/faculty/lanza/Downloads/Gael05a.pdf},
year = {2005}
}
@inproceedings{a,
abstract = {Combining support for single display collaboration with support for asynchronous and remote collaboration in one groupware challenges some basic assumptions of application design and brings up new requirements for application platforms. While user accounts are central in many kinds of groupware, they are not respected in groupware support for multi-user single-screen interaction. Current support for this interaction paradigm does not allow users to act on their own behalf; they have to act on behalf of a host user. We suggest an approach to distinguish the interactions with different users in multi-user single-screen scenarios. Our approach enables applications to link actions to the acting user's account. We describe the integration of suggested concepts in the groupware ProjectTalk, an application for managing XP projects that supports multi-user single-screen interaction. All interacting users are allowed to work with ProjectTalk on their own behalf.},
author = {Steinert, B. and Grunewald, M. and Richter, S. and Lincke, J. and Hirschfeld, R.},
booktitle = {2009 5th International Conference on Collaborative Computing: Networking, Applications and Worksharing},
doi = {10.4108/ICST.COLLABORATECOM2009.8290},
isbn = {978-963-9799-76-9},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Multi-user multi-account interaction in groupware supporting single-display collaboration}},
year = {2009}
}
@inproceedings{a,
author = {Perscheid, Michael and Hirschfeld, Robert},
booktitle = {2014 Software Evolution Week - IEEE Conference on Software Maintenance, Reengineering, and Reverse Engineering (CSMR-WCRE)},
doi = {10.1109/CSMR-WCRE.2014.6747215},
isbn = {978-1-4799-3752-3},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {446--449},
title = {{Follow the path: Debugging tools for test-driven fault navigation}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6747215},
year = {2014}
}
@inproceedings{a,
abstract = {To understand how observable failures come into being, back-in-time debuggers help developers by providing full access to past executions. However, such potentially large execution histories do not include any hints to failure causes. For that reason, developers are forced to ascertain unexpected state properties and wrong behavior completely on their own. Without deep program understanding, back-in-time debugging can end in countless and difficult questions about possible failure causes that consume a lot of time for following failures back to their root causes. In this paper, we present state navigation as a debugging guide that highlights unexpected state properties along execution histories. After deriving common object properties from the expected behavior of passing test cases, we generate likely invariants, compare them with the failing run, and map differences as state anomalies to the past execution. So, developers obtain a common thread through the large amount of run-time data which helps them to answer what causes the observable failure. We implement our completely automatic state navigation as part of our test-driven fault navigation and its Path tools framework. To evaluate our approach, we observe eight developers during debugging four non-trivial failures. As a result, we find out that our state navigation is able to aid developers and to decrease the required time for localizing the root cause of a failure. © 2014 IEEE.},
author = {Perscheid, Michael and Felgentreff, Tim and Hirschfeld, Robert},
booktitle = {2014 Software Evolution Week - IEEE Conference on Software Maintenance, Reengineering, and Reverse Engineering, CSMR-WCRE 2014 - Proceedings},
doi = {10.1109/CSMR-WCRE.2014.6747162},
isbn = {9781479937516},
keywords = {Back-in-time Debugging,Dynamic Analysis,Likely Invariants,Squeak,Test-driven Fault Navigation,Testing},
mendeley-tags = {Squeak},
pages = {124--133},
title = {{Follow the path: Debugging state anomalies along execution histories}},
year = {2014}
}
@inproceedings{galli_ordering_2004,
abstract = {Current unit test frameworks present broken unit tests in an arbitrary order, but developers want to focus on the most specific ones first. We have therefore inferred a partial order of unit tests corresponding to a coverage hierarchy of their sets of covered method signatures: When several unit tests in this coverage hierarchy break, we can guide the developer to the test calling the smallest number of methods. Our experiments with four case studies indicate that this partial order is semantically meaningful, since faults that cause a unit test to break generally cause less specific unit tests to break as well.},
author = {Galli, M. and Lanza, M. and Nierstrasz, O. and Wuyts, R.},
booktitle = {20th IEEE International Conference on Software Maintenance, 2004. Proceedings.},
doi = {10.1109/ICSM.2004.1357796},
isbn = {0-7695-2213-0},
issn = {1063-6773},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {114--123},
publisher = {IEEE},
title = {{Ordering broken unit tests for focused debugging}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=1357796},
year = {2004}
}
@inproceedings{denker_higher_2006,
abstract = {The developers of tools for dynamic analysis are$\backslash$nfaced with choosing from the many approaches to$\backslash$ngathering runtime data. Typically, dynamic analysis$\backslash$ninvolves instrumenting the program under$\backslash$ninvestigation to record its runtime behavior.$\backslash$nCurrent approaches for byte-code based systems like$\backslash$nJava and Smalltalk rely often on inserting byte-code$\backslash$ninto the program under analysis. However, detailed$\backslash$nknowledge of the target programming language or$\backslash$nvirtual machine is required to implement dynamic$\backslash$nanalysis tools. Obtaining and exploiting this$\backslash$nknowledge to build better analysis tools is$\backslash$ncumbersome and often distracts the tool builder from$\backslash$nthe actual goal, which is the analysis of the$\backslash$nruntime behavior of a system. In this paper, we$\backslash$nargue that we need to adopt a higher level view of a$\backslash$nsoftware system when considering the task of$\backslash$nabstracting runtime information. We focus on$\backslash$nobject-oriented virtual machine based languages. We$\backslash$nwant to be able to deal with the runtime system as a$\backslash$ncollection of reified first-class entities. We$\backslash$npropose to achieve this by introducing a layer of$\backslash$nabstraction, i.e., a behavioral middle layer. This$\backslash$nhas the advantage that the task of collecting$\backslash$ndynamic information is not concerned with low level$\backslash$ndetails of a specific language or virtual machine.$\backslash$nThe positive effect of such a behavioral middle$\backslash$nlayer is twofold: on the one hand it provides us$\backslash$nwith a standard API for all dynamic analysis based$\backslash$ntools to use, on the other hand it allows the tool$\backslash$ndeveloper to abstract from the actual implementation$\backslash$ntechnique.},
author = {Denker, Marcus and Greevy, Orla and Lanza, Michele},
booktitle = {2nd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2006)},
keywords = {Squeak,scg-pub skip-doi snf07 jb07 fb06 reflectivity},
mendeley-tags = {Squeak},
pages = {32--38},
publisher = {Universiteit Antwerpen},
title = {{Higher Abstractions for Dynamic Analysis}},
url = {http://scg.unibe.ch/archive/papers/Denk06cHigherAbstractionsPCODA06.pdf$\backslash$nhttp://www.lore.ua.ac.be/Events/PCODA2006/index.html},
year = {2006}
}
@inproceedings{rothlisberger_feature-centric_2007,
author = {R\"{o}thlisberger, David and Greevy, Orla and Lienhard, Adrian},
booktitle = {4th IEEE International Workshop on Visualizing Software for Understanding and Analysis (VISSOFT 2007)},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {150--151},
publisher = {IEEE},
title = {{Feature-centric environment}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4290714},
year = {2007}
}
@inproceedings{a,
abstract = {In this paper we present an authoring tool and an accompanying workflow to create interactive scenarios in a distributed 3D environment by multiple users. With Pitsupai we designed an environment that allows to create collaboratively simple games or game prototypes with a minimal effort, without the need to be a professional game developer. To facilitate collaborative work, our authoring tool uses a scripting language for easy programming and animation in the virtual world and provides awareness aspects - information regarding the whereabouts and current activities of the other participants. Scripts can be edited from within the running virtual world without the need for stopping or restarting it.},
author = {Engelhard, Philipp and Hirschfeld, Robert and Lincke, Jens},
booktitle = {7th International Conference on Creating, Connecting and Collaborating through Computing - C5 2009},
doi = {10.1109/C5.2009.11},
isbn = {9780769536200},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {87--94},
title = {{Pitsupai - Collaborative scripting in a distributed, persistent 3D world}},
year = {2009}
}
@inproceedings{a,
abstract = {Sophie is an authoring tool for interactive multimedia books. The Sophie user can combine different kinds of media and synchronize them with events and time. Such highly interactive systems are difficult to design and to implement. The large amount of functionality provided has to be balanced with a significant ease of use. The standard software engineering approaches for the construction of large software systems are insufficient concerning the special requirements of interactive systems. The tools and materials pattern language is an alternative approach to design interactive systems. This paper exemplifies the use and benefits of tools and materials by the Sophie application.},
author = {Holz, Norman and Hirschfeld, Robert and Lincke, Jens and Haupt, Michael and R\"{u}ger, Michael},
booktitle = {7th International Conference on Creating, Connecting and Collaborating through Computing - C5 2009},
doi = {10.1109/C5.2009.16},
isbn = {9780769536200},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {20--26},
title = {{Sophie - Tools and materials in multimedia book creation}},
year = {2009}
}
@inproceedings{denker_encapsulating_2007,
abstract = {Real world software systems change continuously to meet new demands. Most programming languages and development environments, however, are more concerned with limiting the effects of change rather than enabling and exploiting change. Various techniques and technologies to exploit change have been developed over the years, but there exists no common support for these approaches. We propose Changeboxes as a general-purpose mechanism for encapsulating change as a first-class entity in a running software system. Changeboxes support multiple, concurrent and possibly inconsistent views of software artifacts within the same running system. Since Changeboxes are first-class, they can be manipulated to control the scope of change in a running system. Furthermore, Changeboxes capture the semantics of change. Changeboxes can be used, for example, to encapsulate refactorings, or to replay or analyze the history of changes. In this paper we introduce Changeboxes by means of a prototype implementation. We illustrate the benefits that Changeboxes offer for evolving software systems, and we present the results of a preliminary performance evaluation that assesses the costs associated with Changeboxes while suggesting possible strategies for improvement.},
author = {Denker, Marcus and G\^{\i}rba, T and Lienhard, Adrian and Nierstrasz, Oscar and Renggli, Lukas and Zumkehr, Pascal},
booktitle = {ACM International Conference Proceeding Series},
doi = {10.1145/1352678.1352681},
isbn = {9781605580845},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {286},
pages = {25--49},
publisher = {ACM},
title = {{Encapsulating and exploiting change with changeboxes}},
url = {http://portal.acm.org/citation.cfm?id=1352681},
year = {2007}
}
@incollection{rothlisberger_unanticipated_2007,
author = {Tanter, \'{E}ric and Noy\'{e}, Jacques and Caromel, Denis and Cointe, Pierre},
booktitle = {ACM SIGPLAN Notices},
doi = {10.1145/949343.949309},
isbn = {1581137125},
issn = {03621340},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {11},
pages = {27},
publisher = {Springer},
title = {{Partial behavioral reflection}},
url = {http://link.springer.com/chapter/10.1007/978-3-540-71836-9\_3},
volume = {38},
year = {2003}
}
@inproceedings{scharli_object-oriented_2004,
abstract = {Encapsulation in object-oriented languages has traditionally been based on static type systems. As a consequence, dynamically-typed languages have only limited support for encapsulation. This is surprising, considering that encapsulation is one of the most fundamental and important concepts behind object-oriented programming and that it is essential for writing programs that are maintainable and reliable, and that remain robust as they evolve.},
author = {Sch\"{a}rli, Nathanael and Black, Andrew P. and Ducasse, St\'{e}phane},
booktitle = {ACM SIGPLAN Notices},
doi = {10.1145/1035292.1028988},
isbn = {1-58113-831-9},
issn = {03621340},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {10},
pages = {130},
publisher = {ACM},
title = {{Object-oriented encapsulation for dynamically typed languages}},
url = {http://dl.acm.org/citation.cfm?id=1028988},
volume = {39},
year = {2004}
}
@article{ducasse_traits:_2006,
abstract = {Inheritance is well-known and accepted as a mechanism for reuse in object-oriented languages. Unfortunately, due to the coarse granularity of inheritance, it may be difficult to decompose an application into an optimal class hierarchy that maximizes software reuse. Existing schemes based on single inheritance, multiple inheritance, or mixins, all pose numerous problems for reuse. To overcome these problems we propose traits, pure units of reuse consisting only of methods. We develop a formal model of traits that establishes how traits can be composed, either to form other traits, or to form classes. We also outline an experimental validation in which we apply traits to refactor a non-trivial application into composable units.},
author = {Ducasse, St\'{e}phane and Nierstrasz, Oscar and Sch\"{a}rli, Nathaniel and Wuyts, Roel and Black, Andrew P.},
doi = {10.1145/1119479.1119483},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {Squeak,inheritance,languages,mixins,multiple inheritance,reuse,smalltalk,traits},
mendeley-tags = {Squeak},
number = {2},
pages = {331--338},
shorttitle = {Traits},
title = {{Traits: A mechanism for fine-grained reuse}},
url = {http://dl.acm.org/citation.cfm?id=1119483},
volume = {28},
year = {2006}
}
@article{nierstrasz_separating_2004,
abstract = {As applications evolve, it becomes harder and harder$\backslash$nto separate independent concerns. Small changes to a$\backslash$nsoftware system increasingly affect different parts$\backslash$nof the source code. AOP and related approaches offer$\backslash$nvarious ways to separate concerns into concrete$\backslash$nsoftware artifacts, but what is the $\backslash$emph\{essence\}$\backslash$nof this process? We claim that first-class$\backslash$nnamespaces ---which we refer to as $\backslash$emph\{forms\}---$\backslash$noffer a suitable foundation for separating concerns,$\backslash$nby offering simple, yet expressive mechanisms for$\backslash$ndefining composable abstractions. We demonstrate how$\backslash$nforms help a programmer to separate concerns by$\backslash$nmeans of practical examples in Piccola, an$\backslash$nexperimental composition language.},
author = {Nierstrasz, Oscar and Achermann, Franz},
isbn = {0-321-21976-7},
journal = {Aspect-Oriented Software Development},
keywords = {Squeak,snf04 scg-pub skip-doi jb05},
mendeley-tags = {Squeak},
pages = {243--259},
title = {{Separating Concerns with First-Class Namespaces}},
url = {http://scg.unibe.ch/archive/papers/Nier05aNamespaces.pdf},
year = {2005}
}
@inproceedings{verwaest_safe_2009,
abstract = {Code executed in a fully reflective system switches back and forth between application and interpreter code. These two states can be seen as contexts in which an expression is evaluated. Current language implementations obtain reflective capabilities by exposing objects to the interpreter. However, in doing so these systems break the encapsulation of the application objects. In this paper we propose safe reflection through polymorphism, i.e. by unifying the interface and ensuring the encapsulation of objects from both the interpreter and application context. We demonstrate a homogeneous system that defines the execution semantics in terms of itself, thus enforcing that encapsulation is not broken.},
author = {Verwaest, Toon and Renggli, Lukas},
booktitle = {CASTA '09: Proceedings of the first international workshop on Context-aware software technology and applications},
doi = {10.1145/1595768.1595776},
isbn = {978-1-60558-707-3},
keywords = {Squeak,schemetalk},
mendeley-tags = {Squeak},
pages = {21--24},
publisher = {ACM},
title = {{Safe reflection through polymorphism}},
url = {http://dx.doi.org/10.1145/1595768.1595776},
year = {2009}
}
@inproceedings{ducasse_user-changeable_2007,
abstract = {A trait is a unit of behaviour that can be composed with other traits and used by classes. Traits offer an alternative to multiple inheritance. Conflict resolution of traits, while flexible, does not completely handle accidental method name conflicts: if a trait with method m is composed with another trait defining a different method m then resolving the conflict may prove delicate or infeasible in cases where both versions of m are still needed. In this paper we present freezable traits, which provide an expressive composition mechanism to support unanticipated method composition conflicts. Our solution introduces private trait methods and lets the class composer change method visibility at composition time (from public to private and vice versa). Moreover two class composers may use different composition policies for the same trait, something which is not possible in mainstream languages. This approach respects the two main design principles of traits: the class composer is empowered and traits can be flattened away. We present an implementation of freezable traits in Smalltalk. As a side-effect of this implementation we introduced private (early-bound and invisible) methods to Smalltalk by distinguishing object-sends from self-sends. Our implementation uses compile-time bytecode manipulation and, as such, introduces no run-time penalties.},
author = {Bergel, Alexandre},
booktitle = {Composer},
doi = {10.1145/1297027.1297040},
isbn = {9781595937865},
issn = {0362-1340},
keywords = {Squeak,composition,dynamic typing,encapsulation,informa,tion hiding,traits},
mendeley-tags = {Squeak},
number = {10},
pages = {171--190},
publisher = {ACM},
shorttitle = {User-changeable visibility},
title = {{User-Changeable Visibility : Resolving Unanticipated Name Clashes in Traits}},
url = {http://portal.acm.org/citation.cfm?id=1297027.1297040},
volume = {42},
year = {2007}
}
@article{a,
abstract = {In contemporary aspect-oriented languages, pointcuts are usually specified directly in terms of the structure of the source code. The definition of such low-level pointcuts requires aspect developers to have a profound understanding of the entire application's implementation and often leads to complex, fragile and hard-to-maintain pointcut definitions. To resolve these issues, we present an aspect-oriented programming system that features a logic-based pointcut language that is open such that it can be extended with application-specific pointcut predicates. These predicates define an application-specific model that serves as a contract that base program developers provide and aspect developers can depend upon. As a result, pointcuts can be specified in terms of this more high-level model of the application which confines all intricate implementation details that are otherwise exposed in the pointcut definitions themselves. ?? 2007 Elsevier Ltd. All rights reserved.},
author = {Brichau, Johan and Kellens, Andy and Gybels, Kris and Mens, Kim and Hirschfeld, Robert and D'Hondt, Theo},
doi = {10.1016/j.cl.2007.05.004},
isbn = {9783540718352},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Aspect-oriented programming,AspectS,Logic metaprogramming,Pointcut languages,SOUL,Squeak},
mendeley-tags = {AspectS,SOUL,Squeak},
number = {2-3},
pages = {66--82},
title = {{Application-specific models and pointcuts using a logic metalanguage}},
volume = {34},
year = {2008}
}
@inproceedings{a,
abstract = {In contemporary aspect-oriented languages, pointcuts are usually specified directly in terms of the structure of the source code. The definition of such low-level pointcuts requires aspect developers to have a profound understanding of the entire application's implementation and often leads to complex, fragile and hard-to-maintain pointcut definitions. To resolve these issues, we present an aspect-oriented programming system that features a logic-based pointcut language that is open such that it can be extended with application-specific pointcut predicates. These predicates define an application-specific model that serves as a contract that base program developers provide and aspect developers can depend upon. As a result, pointcuts can be specified in terms of this more high-level model of the application which confines all intricate implementation details that are otherwise exposed in the pointcut definitions themselves. ?? 2007 Elsevier Ltd. All rights reserved.},
author = {Brichau, Johan and Kellens, Andy and Gybels, Kris and Mens, Kim and Hirschfeld, Robert and D'Hondt, Theo},
booktitle = {Computer Languages, Systems and Structures},
doi = {10.1016/j.cl.2007.05.004},
isbn = {9783540718352},
issn = {14778424},
keywords = {Aspect-oriented programming,Logic metaprogramming,Pointcut languages,Squeak},
mendeley-tags = {Squeak},
pages = {66--82},
title = {{Application-specific models and pointcuts using a logic metalanguage}},
volume = {34},
year = {2008}
}
@article{denker_runtime_2006,
abstract = {Transforming programs to alter their semantics is of wide interest, for purposes as diverse as off-the-shelf component adaptation, optimization, trace generation, and experimentation with new language features. The current wave of interest in advanced technologies for better separation of concerns, such as aspect-oriented programming, is a solid testimony of this fact. Strangely enough, almost all proposals are formulated in the context of Java, in which tool providers encounter severe restrictions due to the rigidity of the environment. This paper presents BYTESURGEON, a library to transform binary code in Smalltalk. BYTESURGEON takes full advantage of the flexibility of the Squeak environment to enable bytecode transformation at runtime, thereby allowing dynamic, on-the-fly modification of applications. BYTESURGEON operates on bytecode in order to cope with situations where the source code is not available, while providing appropriate high-level abstractions so that users do not need to program at the bytecode level. We illustrate the use of BYTESURGEON via the implementation of method wrappers and a simple MOP, and report on its efficiency. © 2005 Elsevier Ltd. All rights reserved.},
author = {Denker, Marcus and Ducasse, St\'{e}phane and Tanter, \'{E}ric},
doi = {10.1016/j.cl.2005.10.002},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Bytecode transformation,Metaprogramming,Object-oriented programming,Smalltalk,Squeak},
mendeley-tags = {Squeak},
number = {2-3},
pages = {125--139},
title = {{Runtime bytecode transformation for Smalltalk}},
url = {http://www.sciencedirect.com/science/article/pii/S1477842405000436},
volume = {32},
year = {2006}
}
@article{rothlisberger_unanticipated_2008,
abstract = {Dynamic, unanticipated adaptation of running systems is of interest in a variety of situations, ranging from functional upgrades to on-the-fly debugging or monitoring of critical applications. In this paper we study a particular form of computational reflection, called unanticipated partial behavioral reflection (UPBR), which is particularly well suited for unanticipated adaptation of real-world systems. Our proposal combines the dynamicity of unanticipated reflection, i.e., reflection that does not require preparation of the code of any sort, and the selectivity and efficiency of partial behavioral reflection (PBR). First, we propose unanticipated partial behavioral reflection which enables the developer to precisely select the required reifications, to flexibly engineer the metalevel and to introduce the metabehavior dynamically. Second, we present a system supporting unanticipated partial behavioral reflection in Squeak Smalltalk, called GEPPETTO, and illustrate its use with a concrete example of a web application. Benchmarks validate the applicability of our proposal as an extension to the standard reflective abilities of Smalltalk. © 2007 Elsevier Ltd. All rights reserved.},
author = {R\"{o}thlisberger, David and Denker, Marcus and Tanter, \'{E}ric},
doi = {10.1016/j.cl.2007.05.001},
isbn = {978-3-540-71835-2},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Metaobject protocol,Metaprogramming,Reflection,Smalltalk,Squeak},
mendeley-tags = {Squeak},
number = {2-3},
pages = {46--65},
shorttitle = {Unanticipated partial behavioral reflection},
title = {{Unanticipated partial behavioral reflection: Adapting applications at runtime}},
url = {http://www.sciencedirect.com/science/article/pii/S1477842407000127},
volume = {34},
year = {2008}
}
@article{haldiman_practical_2009,
abstract = {Most languages fall into one of two camps: either they adopt a unique, static type system, or they abandon static type-checks for run-time checks. Pluggable types blur this division by (i) making static type systems optional, and (ii) supporting a choice of type systems for reasoning about different kinds of static properties. Dynamic languages can then benefit from static-checking without sacrificing dynamic features or committing to a unique, static type system. But the overhead of adopting pluggable types can be very high, especially if all existing code must be decorated with type annotations before any type-checking can be performed. We propose a practical and pragmatic approach to introduce pluggable type systems to dynamic languages. First of all, only annotated code is type-checked. Second, limited type inference is performed on unannotated code to reduce the number of reported errors. Finally, external annotations can be used to type third-party code. We present TypePlug, a Smalltalk implementation of our framework, and report on experience applying the framework to three different pluggable type systems. ?? 2008 Elsevier Ltd. All rights reserved.},
author = {Haldiman, Niklaus and Denker, Marcus and Nierstrasz, Oscar},
doi = {10.1016/j.cl.2008.06.003},
isbn = {9781605580845},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Dynamic languages,Programming languages,Squeak,Type systems},
mendeley-tags = {Squeak},
number = {1},
pages = {48--62},
title = {{Practical, pluggable types for a dynamic language}},
url = {http://www.sciencedirect.com/science/article/pii/S1477842408000262},
volume = {35},
year = {2009}
}
@article{nierstrasza_classboxes:_2004,
abstract = {A class extension is a method that is defined in a module, but whose class is defined elsewhere. Class extensions offer a convenient way to incrementally modify existing classes when subclassing is inappropriate. Unfortunately existing approaches suffer from various limitations. Either class extensions have a global impact, with possibly negative effects for unexpected clients, or they have a purely local impact, with negative results for collaborating clients. Furthermore, conflicting class extensions are either disallowed, or resolved by linearization, with consequent negative effects. To solve these problems we present classboxes, a module system for object-oriented languages that provides for method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model we have implemented it in the Squeak Smalltalk environment, and performed benchmarks. © 2005 Elsevier Ltd. All rights reserved.},
author = {Bergel, Alexandre and Ducasse, St\'{e}phane and Nierstrasz, Oscar and Wuyts, Roel},
doi = {10.1016/j.cl.2004.11.002},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Class extension,Language design,Method lookup,Modules,Selector namespace,Squeak},
mendeley-tags = {Squeak},
number = {3-4},
pages = {107--126},
shorttitle = {Classboxes},
title = {{Classboxes: Controlling visibility of class extensions}},
url = {http://www.esug.org/data/ESUG2004/iam-04-008.pdf\#page=186},
volume = {31},
year = {2005}
}
@article{bergel_stateful_2008,
abstract = {Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within stateless traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. We present an approach to stateful traits that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. We demonstrate by means of a formal object calculus that adding state to traits preserves the flattening property: traits contained in a program can be compiled away. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy. © 2007 Elsevier Ltd. All rights reserved.},
author = {Bergel, Alexandre and Ducasse, St\'{e}phane and Nierstrasz, Oscar and Wuyts, Roel},
doi = {10.1016/j.cl.2007.05.003},
isbn = {978-3-540-71835-2},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Eiffel,Flattening,Jigsaw,Mixin,Multiple-inheritance,Squeak,Traits},
mendeley-tags = {Squeak},
number = {2-3},
pages = {83--108},
title = {{Stateful traits and their formalization}},
url = {http://www.sciencedirect.com/science/article/pii/S1477842407000140},
volume = {34},
year = {2008}
}
@article{wuytsb_uniform_2004,
abstract = {In pure object-oriented languages, classes are objects, instances of other classes called metaclasses. In the same way as classes define the properties of their instances, metaclasses define the properties of classes. It is therefore very natural to wish to reuse class properties, utilizing them amongst several classes. However this introduced metaclass composition problems, i.e., code fragments applied to one class may break when used on another class due to the inheritance relationship between their respective metaclasses. Numerous approaches have tried to solve metaclass composition problems, but they always resort to an ad-hoc manner of handling conflicting properties, alienating the meta-programmer. We propose a uniform approach that represents class properties as traits, groups of methods that act as a unit of reuse from which classes are composed. Like all the other classes in the system, metaclasses are composed out of traits. This solution supports the reuse of class properties, and their safe and automatic composition based on explicit conflict resolution. The paper discusses traits and our solution, shows concrete examples implemented in the Smalltalk environment Squeak, and compares our approach with existing models for composing class properties. © 2005 Elsevier Ltd. All rights reserved.},
author = {Ducasse, St\'{e}phane and Sch\"{a}rli, Nathanael and Wuyts, Roel},
doi = {10.1016/j.cl.2004.11.003},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Metaclass composition,Mixins,Reflective kernel,Reuse,Squeak,Traits},
mendeley-tags = {Squeak},
number = {3-4},
pages = {143--164},
title = {{Uniform and safe metaclass composition}},
url = {http://www.iam.unibe.ch/~ducasse/Web/Demoes/ESUG2004Proceedings.pdf\#page=160},
volume = {31},
year = {2005}
}
@article{scharli_browser_2004,
abstract = {Much of the elegance and power of Smalltalk comes from its programming environment and tools. First introduced more than 20 years ago, the Smalltalk browser enables programmers to "home in" on particular methods using a hierarchy of manually-defined classifications. By its nature, this classification scheme says a lot about the desired state of the code, but little about the actual state of the code as it is being developed. We have extended the Smalltalk browser with dynamically computed virtual categories that dramatically improve the browser's support for incremental programming. We illustrate these improvements by example, and describe the algorithms used to compute the virtual categories efficiently. © 2003 Elsevier Ltd. All rights reserved.},
author = {Sch\"{a}rli, Nathanael and Black, Andrew P.},
doi = {10.1016/j.cl.2003.09.004},
isbn = {1477-8424},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Incremental programming,Intentional programming,Method reachability,Requires set,Smalltalk browser,Squeak},
mendeley-tags = {Squeak},
number = {1-2},
pages = {79--95},
title = {{A browser for incremental programming}},
url = {http://www.sciencedirect.com/science/article/pii/S1477842403000460},
volume = {30},
year = {2004}
}
@article{lienhard_taking_2009,
abstract = {A large body of research analyzes the runtime execution of a system to extract abstract behavioral views. Those approaches primarily analyze control flow by tracing method execution events or they analyze object graphs of heap memory snapshots. However, they do not capture how objects are passed through the system at runtime. We refer to the exchange of objects as the object flow, and we claim that it is necessary to analyze object flows if we are to understand the runtime of an object-oriented application. We propose and detail object flow analysis, a novel dynamic analysis technique that takes this new information into account. To evaluate its usefulness, we present a visual approach that allows a developer to study classes and components in terms of how they exchange objects at runtime. We illustrate our approach on three case studies. © 2008 Elsevier Ltd. All rights reserved.},
author = {Lienhard, Adrian and Ducasse, St\'{e}phane and G\^{\i}rba, Tudor},
doi = {10.1016/j.cl.2008.05.006},
isbn = {978-1-60558-084-5},
issn = {14778424},
journal = {Computer Languages, Systems and Structures},
keywords = {Dynamic analysis,Object flow analysis,Squeak},
mendeley-tags = {Squeak},
number = {1},
pages = {63--79},
title = {{Taking an object-centric view on dynamic information with object flow analysis}},
url = {http://www.sciencedirect.com/science/article/pii/S1477842408000201},
volume = {35},
year = {2009}
}
@inproceedings{a,
author = {Steinert, Bastian and Hirschfeld, Robert},
booktitle = {Design Thinking Research: Building Innovation Eco-Systems},
doi = {10.1007/978-3-319-01303-9},
isbn = {9783319013039},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {219--238},
title = {{How to Compare Performance in Program Design Activities : Towards an Empirical Evaluation of CoExist}},
year = {2014}
}
@inproceedings{a,
abstract = {Arguably programming involves design: computational logic – the program – is constantly reorganized to keep complexity manageable and provide for current and future coding activities to be feasible. However, design practices have gained less attention in the field of programming, even though decades of research on design have led to a large body of knowledge about theories, methods, and best practices. This chapter reports on the first results of our research efforts to transfer and apply design knowledge to programming activities. We improved tool support for software developers in two respects, both of which are based on key concepts in design practices: continuous feedback and ease of exploration.},
author = {Steinert, Bastian and Hirschfeld, Robert},
booktitle = {Design Thinking Research: Studying Co-Creation in Practice},
doi = {10.1007/978-3-642-21643-5},
isbn = {978-3-642-21642-8},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {259--277},
title = {{Applying Design Knowledge to Programming}},
url = {http://link.springer.com/10.1007/978-3-642-21643-5},
year = {2012}
}
@inproceedings{a,
abstract = {Business processmanagement is at the heart of organizations. It provides concepts andmethods to capture, analyze and improve operational procedures in the daily business of organizations. The elicitation of process models is the first step in any process improvement project. Processmodels mediate communication between the different stakeholders involved, such as, for instance, business analysts, process participants, and software architects. Process models provide a shared understand- ing, so that everyone can contribute knowledge. Based on design thinking principles, this paper develops a method that aims at improving business process modeling. To achieve this goal, we introduce physical building blocks and methodological guidance to fundamentally change theway peo- ple interact with process models. Tangible prototypes have been successfully used in design thinking, and initial experiments show that a tangible toolset is a promis- ing approach to improve business process modeling and comprehension. The focus of this paper is on the insights we got during the cooperative research project, i.e., the research path we took. Finally, we explain our research method and outline the next steps.},
author = {Luebbe, Alexander and Weske, Mathias},
booktitle = {Design Thinking: Understand – Improve – Apply},
doi = {10.1007/978-3-642-13757-0},
isbn = {978-3-642-13756-3},
keywords = {BPM,Business Process Modeling,Design Thinking,Squeak},
mendeley-tags = {Squeak},
pages = {181--195},
title = {{Bringing Design Thinking to Business Process Modeling}},
url = {http://link.springer.com/10.1007/978-3-642-13757-0},
year = {2011}
}
@article{denker_software_2007,
author = {Denker, Marcus and Ducasse, St\'{e}phane},
doi = {10.1016/j.entcs.2006.08.003},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {81--91},
shorttitle = {Software evolution from the field},
title = {{Software Evolution from the Field}},
url = {http://www.sciencedirect.com/science/article/pii/S1571066106005305},
volume = {166},
year = {2007}
}
@incollection{galli_correlating_2004,
abstract = {Research Questions: What are the relationships between unit tests and between unit tests and methods under test? What can be gained by making this relationships explicit? How does the concept of method examples compare with other possible techniques to relate this entities?},
author = {G\"{a}lli, Markus},
booktitle = {Extreme Programming and Agile Processes in Software Engineering},
doi = {10.1007/b98150},
isbn = {978-3-540-22137-1},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {317},
publisher = {Springer},
title = {{Correlating Unit Tests and Methods under Test}},
url = {http://link.springer.com.eaccess.ub.tum.de/chapter/10.1007/978-3-540-24853-8\_48},
volume = {3092},
year = {2004}
}
@incollection{nierstrasz_calculus_2003,
abstract = {Many competing definitions of software components have been proposed over the years, but still today there is only partial agreement over such basic issues as granularity (are components bigger or smaller than objects, packages, or application?), instantiation (do components exist at run-time or only at compile-time?), and state (should we distinguish between components and “instances” of components?). We adopt a minimalist view in which components can be distinguished by composable interfaces. We have identified a number of key features and mechanisms for expressing composable software, and propose a calculus for modeling components, based on the asynchronous $\pi$ calculus extended with explicit namespaces, or “forms”. This calculus serves as a semantic foundation and an executable abstract machine for Piccola, an experimental composition language. The calculus also enables reasoning about compositional styles and evaluation strategies for Piccola. We present the design rationale for the Piccola calculus, and briefly outline some of the results obtained.},
author = {Nierstrasz, Oscar and Achermann, Franz},
booktitle = {Formal Methods for Components and Objects},
editor = {de Boer, Frank S and Bonsangue, Marcello M and Graf, Susanne and de Roever, Willem-Paul},
isbn = {978-3-540-20303-2, 978-3-540-39656-7},
keywords = {Compilers,Interpreters,Logics and Meanings of Programs,Operating Systems,Programming Languages,Squeak,software engineering},
mendeley-tags = {Squeak},
number = {2852},
pages = {339--360},
publisher = {Springer Berlin Heidelberg},
series = {Lecture \{Notes\} in \{Computer\} \{Science\}},
title = {{A Calculus for Modeling Software Components}},
url = {http://link.springer.com/chapter/10.1007/978-3-540-39656-7\_14},
volume = {2852},
year = {2002}
}
@inproceedings{rothlisberger_supporting_2009,
abstract = {Mainstream IDEs generally rely on the static structure of a software project to support browsing and navigation. We propose HeatMaps, a simple but highly configurable technique to enrich the way an IDE displays the static structure of a software system with additional kinds of information. A HeatMap highlights software artifacts according to various metric values, such as bright red or pale blue, to indicate their potential degree of interest. We present a prototype system that implements HeatMaps, and we describe an initial study that assesses the degree to which different HeatMaps effectively guide developers in navigating software.},
author = {R\"{o}thlisberger, David and Nierstrasz, Oscar and Ducasse, St\'{e}phane and Pollet, Damien and Robbes, Romain},
booktitle = {IEEE International Conference on Program Comprehension},
doi = {10.1109/ICPC.2009.5090052},
isbn = {9781424439973},
issn = {1063-6897},
keywords = {Development environments,Program comprehension,Software analysis,Squeak,Static analysis},
mendeley-tags = {Squeak},
pages = {253--257},
publisher = {IEEE},
title = {{Supporting task-oriented navigation in IDEs with configurable HeatMaps}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=5090052},
year = {2009}
}
@inproceedings{lienhard_tracking_2007,
abstract = {The domain-specific ontology of a software system includes a set of features and their relationships. While the problem of locating features in object-oriented programs has been widely studied, runtime dependencies between features are less well understood. Features cannot be understood in isolation, since their behavior often depends on objects created and referenced in previously exercised features. It is difficult to spot runtime dependencies between features just by browsing source code. Hence, code modifications intended for one feature, often inadvertently affect other features. In this paper, we propose an approach to precisely identify dependencies between features based on a fine-grained dynamic analysis which captures details about how objects are referenced at runtime. The results of two case studies indicate that our approach helps software maintainers in understanding critical feature dependencies.},
author = {Lienhard, Adrian and Greevy, Orla and Nierstrasz, Oscar},
booktitle = {IEEE International Conference on Program Comprehension},
doi = {10.1109/ICPC.2007.38},
isbn = {0769528600},
issn = {1063-6897},
keywords = {Dynamic analysis,Feature analysis,Object aliasing,Reverse engineering,Squeak,Visualization},
mendeley-tags = {Squeak},
pages = {59--68},
publisher = {IEEE},
title = {{Tracking objects to detect feature dependencies}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4268241},
year = {2007}
}
@article{ducasse_class_2005,
abstract = {Understanding source code is an important task in the maintenance of software systems. Legacy systems are not only limited to procedural languages, but are also written in object-oriented languages. In such a context, understanding classes is a key activity as they are the cornerstone of the object-oriented paradigm and the primary abstraction from which applications are built. Such an understanding is however difficult to obtain because of reasons such as the presence of late binding and inheritance. A first level of class understanding consists of the understanding of its overall structure, the control flow among its methods, and the accesses on its attributes. We propose a novel visualization of classes called class blueprint that is based on a semantically enriched visualization of the internal structure of classes. This visualization allows a software engineer to build a first mental model of a class that he validates via opportunistic code-reading. Furthermore, we have identified visual patterns that represent recurrent situations and as such convey additional, information to the viewer. The contributions of this article are the class blueprint, a novel visualization of the internal structure of classes, the identification of visual patterns, and the definition of a vocabulary based on these visual patterns. We have performed several case studies of which one is presented in depth, and validated the usefulness of the approach in a controlled experiment.},
author = {Ducasse, St\'{e}phane and Lanza, Michele},
doi = {10.1109/TSE.2005.14},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Object-oriented programming,Reverse engineering,Smalltalk,Software visualization,Squeak,Visual patterns},
mendeley-tags = {Squeak},
number = {1},
pages = {75--90},
pmid = {1392721},
shorttitle = {The class blueprint},
title = {{The class blueprint: Visually supporting the understanding of classes}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=1392721},
volume = {31},
year = {2005}
}
@inproceedings{a,
abstract = {Aspect composition is still a hot research topic$\backslash$nwhere there is no consensus on how to express where$\backslash$nand when aspects have to be composed into a base$\backslash$nsystem. In this paper we present a modular construct$\backslash$nfor aspects, called aspectboxes, that enables$\backslash$naspects application to be limited to a well defined$\backslash$nscope. An aspectbox encapsulates class and aspect$\backslash$ndefinitions. Classes can be imported into an$\backslash$naspectbox defining a base system to which aspects$\backslash$nmay then be applied. Refinements and instrumentation$\backslash$ndefined by an aspect are visible only within this$\backslash$nparticular aspectbox leaving other parts of the$\backslash$nsystem unaffected.},
author = {Bergel, Alexandre and Hirschfeld, Robert and Clarke, Siobh\`{a}n and Costanza, Pascal},
booktitle = {In Proceedings of the International Conference on Software and Data Technologies (ICSOFT 2006)},
isbn = {972-8865-69-4},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {29--38},
title = {{Aspectboxes --- Controlling the Visibility of Aspects}},
url = {http://www.cs.tcd.ie/Alexandre.Bergel/download/papers/Berg06c-Aspectboxes.pdf},
year = {2006}
}
@article{bergel_classboxescontrolling_2007,
author = {Bergel, Alexandre},
journal = {it–Information Technology (vormals it+ ti)},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {4},
pages = {260--263},
title = {{Classboxes–Controlling Visibility of Class Extensions (Classboxes–Kontrollierte Sichtbarkeit von Klassenerweiterungen)}},
url = {http://www.degruyter.com/view/j/itit.2007.49.issue-4/itit.2007.49.4.260/itit.2007.49.4.260.xml},
volume = {49},
year = {2007}
}
@article{wuyts_unanticipated_2004,
abstract = {The increasing complexity of software development spawns lots of specialised tools to edit code, employ UML schemes, integrate documentation, and so on. The problem is that the tool builders themselves are responsible for making their tools interoperable with other tools or development environments. Because they cannot anticipate all other tools they can integrate with, a lot of tools cannot co-operate. This paper introduces the classication model, a lightweight integration medium that enables unrelated tools that were not meant to be integrated to cooperate easily. Moreover, the tool integration is done by a tool integrator, and not by the tool builder. To validate this claim, we show how to integrate several third-party tools using the classication model, and how it forms the foundation for the StarBrowser, a Smalltalk browser integrating different tools.},
author = {Wuyts, Roel and Ducasse, St\'{e}phane},
doi = {10.1016/j.cl.2003.08.003},
journal = {Journal of Computer Languages Systems and Structures},
keywords = {Squeak,recast04 scg pub jb04 decomp pub},
mendeley-tags = {Squeak},
number = {1-2},
pages = {63--77},
title = {{Unanticipated Integration of Development Tools using the Classification Model}},
url = {http://scg.unibe.ch/archive/papers/Wuyt04aClassifications.pdf},
volume = {30},
year = {2004}
}
@article{reichhart_rule-based_2007,
abstract = {With the success of agile methodologies more and$\backslash$nmore projects develop large test suites to ensure$\backslash$nthat the system is behaving as expected. Not only do$\backslash$ntests ensure correctness, but they also offer a live$\backslash$ndocumentation for the code. However, as the system$\backslash$nevolves, the tests need to evolve as well to keep up$\backslash$nwith the system, and as the test suite grows larger,$\backslash$nthe effort invested into maintaining tests is a$\backslash$nsignificant activity. In this context, the quality$\backslash$nof tests becomes an important issue, as developers$\backslash$nneed to assess and understand the tests they have to$\backslash$nmaintain. In this paper we present TestLint, an$\backslash$napproach together with an experimental tool for$\backslash$nqualifying tests. We define a set of criteria to$\backslash$ndetermine test quality, and we evaluate our approach$\backslash$non a large sample of unit tests found in open-source$\backslash$nprojects.},
author = {Reichhart, Stefan and G\^{\i}rba, Tudor and Ducasse, St\'{e}phane},
doi = {10.5381/jot.2007.6.9.a12},
issn = {16601769},
journal = {Journal of Object Technology},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {9},
pages = {231--251},
title = {{Rule-based assessment of test quality}},
url = {http://www.jot.fm/issues/issue\_2007\_10/paper12/index},
volume = {6},
year = {2007}
}
@article{nierstrasz_flattening_2006,
abstract = {Traits are fine-grained components that can be used$\backslash$nto compose classes, while avoiding many of the$\backslash$nproblems of multiple inheritance and mixin-based$\backslash$napproaches. Since most implementations of traits$\backslash$nhave focused on dynamically-typed languages, the$\backslash$nquestion naturally arises, how can one best$\backslash$nintroduce traits to statically-typed languages, like$\backslash$n\{Java\} and C\#? In this paper we argue that the$\backslash$nflattening property of traits should be used as a$\backslash$nguiding principle for any attempt to add traits to$\backslash$nstatically-typed languages. This property$\backslash$nessentially states that, semantically, traits can be$\backslash$ncompiled away. We demonstrate how this principle$\backslash$napplies to FTJ, a conservative extension to$\backslash$nFeatherweight \{Java\}.},
author = {Nierstrasz, Oscar and Ducasse, St\'{e}phane and Sch\"{a}rli, Nathanael},
doi = {10.5381/jot.2006.5.4.a4},
issn = {16601769},
journal = {Journal of Object Technology},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {4},
pages = {129--148},
title = {{Flattening traits}},
url = {http://boris.unibe.ch/19424/1/article4.pdf},
volume = {5},
year = {2006}
}
@inproceedings{a,
author = {Perscheid, Michael and Haupt, Michael and Hirschfeld, Robert and Masuhara, Hidehiko},
booktitle = {Journal of the Japan Society for Software Science and Technology},
issn = {02896540},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {3\_188--3\_211},
title = {{Test-driven Fault Navigation for Debugging Reproducible Failures}},
volume = {29},
year = {2012}
}
@article{bergel_analyzing_2005,
abstract = {Each object-oriented programming language proposes$\backslash$nvarious grouping mechanisms to bundle interacting$\backslash$nclasses (i.e., packages, modules, selector$\backslash$nnamespaces, etc). To understand such diversity and$\backslash$nto compare the different approaches, a common$\backslash$nfoundation is needed. As far as we are aware of, no$\backslash$nmajor attempt that would go in that direction has$\backslash$nbeen realized. In this paper we present a simple$\backslash$nmodule calculus together with a set of operators for$\backslash$nmodeling the composition semantics of different$\backslash$ngrouping mechanisms. Using this module calculus we$\backslash$nare able to express the semantics of \{Java\}$\backslash$npackages, C\# namespaces, Ruby modules, selector$\backslash$nnamespaces, gbeta classes, classboxes, MZScheme$\backslash$nunits, and MixJuice modules. This calculus supports$\backslash$nthe identification of system families sharing$\backslash$nsimilar characteristics. In addition it provides a$\backslash$nuniform way to represent and analyze fine-grained$\backslash$nmodule semantics.},
author = {Bergel, Alexandre and Ducasse, St\'{e}phane and Nierstrasz, Oscar},
issn = {0958695X},
journal = {Journal of Universal Computer Science},
keywords = {Squeak,scg-pub skip-doi jb06 classbox snf06 stefPub alexP},
mendeley-tags = {Squeak},
number = {10},
pages = {1613--1644},
title = {{Analyzing Module Diversity}},
url = {http://www.jucs.org/jucs\_11\_10/analyzing\_module\_diversity$\backslash$nhttp://scg.unibe.ch/archive/papers/Berg05cModuleDiversity.pdf},
volume = {11},
year = {2005}
}
@article{minjat_mise_2005,
abstract = {The trait model is complementary to class$\backslash$ninheritance and allows collections of methods to be$\backslash$nreused by several classes. The classbox model allows$\backslash$na collection of classes to be locally extended with$\backslash$nvariables and/or methods addition. This paper$\backslash$ndescribes a symbiosis of these two models: classes$\backslash$ncan be locally extended by using a trait. It is$\backslash$nillustrated by an efficient implementation of the$\backslash$ncollaboration model where a collaboration is$\backslash$nrepresented by a classbox and a role by a trait.},
author = {Minjat, Florian and Bergel, Alexandre and Cointe, Pierre and Ducasse, St\'{e}phane},
doi = {10.3166/objet.11.1-2.33-46},
issn = {12621137},
journal = {L'objet},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {1-2},
pages = {33--46},
title = {{Mise en symbiose des traits et des classboxes. Application \`{a} l'expression des collaborations}},
url = {http://www.researchgate.net/profile/Stephane\_Ducasse/publication/228642592\_Mise\_en\_symbiose\_des\_traits\_et\_des\_classboxes\_Application\_\_l'expression\_des\_collaborations/links/00463536dc0d786604000000.pdf},
volume = {11},
year = {2005}
}
@article{bergel_scoped_2005,
abstract = {Atomically introducing changes to a group of classes$\backslash$nis a challenging task. In addition, certain$\backslash$napplications require that changes be applied$\backslash$ndynamically without shutting down and restarting the$\backslash$napplication. In this paper we present an extension$\backslash$nof classboxes to make them dynamic. A classbox is a$\backslash$nkind of module that supports class extension and$\backslash$ninstance variable addition. Class extensions and$\backslash$ndefinitions defined in a classbox represent an$\backslash$naspect. In addition, with classboxes, aspects are$\backslash$ndynamically applied to, removed from hot- in a$\backslash$nsystem. Such aspects may crosscut a large number of$\backslash$nclasses which are extended by adding or redefining$\backslash$nexisting methods and adding new instance variables.$\backslash$nFinally the aspects are scoped i.e., they are local$\backslash$nto the classboxes that define them.},
author = {Bergel, Alexandre and Ducasse, St\'{e}phane},
doi = {10.3166/objet.11.3.53-68},
issn = {12621137},
journal = {L'objet},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {3},
pages = {53--68},
title = {{Scoped and Dynamic Aspects with Classboxes}},
url = {http://cat.inist.fr/?aModele=afficheN\&cpsidt=17306587},
volume = {11},
year = {2005}
}
@inproceedings{a,
abstract = {A manual and explicit activity, the frequent selection and execution of tests requires considerable discipline. Our approach automatically derives a subset of tests based on actual modifications to the code base at hand, then continuously executes them transparently in the background, and so supports developers in instantly assessing the effect of their coding activities with respect to the overall set of unit tests to be passed. We apply techniques of selective regression testing, mainly relying on dynamic analysis. By taking advantage of the internal program representation available in IDEs, we do not need to rely on expensive comparisons of different program versions to detect modified code entities. © Springer-Verlag Berlin Heidelberg 2010.},
author = {Steinert, Bastian and Haupt, Michael and Krahn, Robert and Hirschfeld, Robert},
booktitle = {Lecture Notes in Business Information Processing},
doi = {10.1007/978-3-642-13054-0\_10},
isbn = {9783642130533},
issn = {18651348},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {132--146},
title = {{Continuous selective testing}},
volume = {48 LNBIP},
year = {2010}
}
@article{bergel_meta-driven_2007,
author = {Bergel, Alexandre and Ducasse, St\'{e}phane and Putney, Colin and Wuyts, Roel},
journal = {Lecture notes in computer science},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {134--156},
title = {{Meta-driven browsers}},
url = {http://link.springer.com/content/pdf/10.1007/978-3-540-71836-9.pdf\#page=141},
volume = {4406},
year = {2007}
}
@incollection{scharli_traits:_2003,
abstract = {Despite the undisputed prominence of inheritance as the fundamental reuse mechanism in object-oriented programming languages, the main variants single inheritance, multiple inheritance, and mixin inheritance all suffer from conceptual and practical problems. In the first part of this paper, we identify and illustrate these problems. We then present traits, a simple compositional model for structuring object-oriented programs. A trait is essentially a group of pure methods that serves as a building block for classes and is a primitive unit of code reuse. In this model, classes are composed from a set of traits by specifying glue code that connects the traits together and accesses the necessary state. We demonstrate how traits overcome the problems arising from the different vari- ants of inheritance, we discuss how traits can be implemented effectively, and we summarize our experience applying traits to refactor an existing class hierarchy.},
author = {Sch\"{a}rli, N and Ducasse, S and Nierstrasz, O and Black, A},
booktitle = {Lecture Notes in Computer Science},
doi = {10.1007/b11832},
editor = {Cardelli, Luca},
isbn = {978-3-540-40531-3},
issn = {1611-3349},
keywords = {Squeak,inheritance,mixins,multiple inheritance,reuse,smalltalk,traits},
mendeley-tags = {Squeak},
number = {2743},
pages = {248--274},
publisher = {Springer Berlin Heidelberg},
series = {Lecture \{Notes\} in \{Computer\} \{Science\}},
shorttitle = {Traits},
title = {{Traits: Composable units of behaviour}},
url = {http://www.springerlink.com/index/169MBRAEPN4GMYD2.pdf},
volume = {2743},
year = {2003}
}
@article{lienhard_practical_2008,
author = {Lienhard, Adrian and G\^{\i}rba, Tudor and Nierstrasz, Oscar},
journal = {Lecture Notes in Computer Science},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {592--615},
title = {{Practical object-oriented back-in-time debugging}},
url = {http://link.springer.com/content/pdf/10.1007/978-3-540-70592-5.pdf\#page=604},
volume = {5142},
year = {2008}
}
@inproceedings{a,
author = {Steinert, Bastian and Perscheid, Michael and Beck, Martin and Lincke, Jens and Hirschfeld, Robert},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-642-05031-2\_18},
isbn = {3642050301},
issn = {03029743},
keywords = {Dynamic analysis,Program comprehension,Squeak,Test coverage},
mendeley-tags = {Squeak},
pages = {235--240},
title = {{Debugging into examples leveraging tests for program comprehension}},
volume = {5826 LNCS},
year = {2009}
}
@inproceedings{bolz_back_2008,
abstract = {We report on our experiences with the Spy project, including implementation details and benchmark results. Spy is a re-implementation of the Squeak (i.e., Smalltalk-80) VM using the PyPy toolchain. The PyPy project allows code written in RPython, a subset of Python, to be translated to a multitude of different backends and architectures. During the translation, many aspects of the implementation can be independently tuned, such as the garbage collection algorithm or threading implementation. In this way, a whole host of interpreters can be derived from one abstract interpreter definition. Spy aims to bring these benefits to Squeak, allowing for greater portability and, eventually, improved performance. The current Spy codebase is able to run a small set of benchmarks that demonstrate performance superior to many similar Smalltalk VMs, but which still run slower than in Squeak itself. Spy was built from scratch over the course of a week during a joint Squeak-PyPy Sprint in Bern last autumn.},
author = {Bolz, Carl Friedrich and Kuhn, Adrian and Lienhard, Adrian and Matsakis, Nicholas D. and Nierstrasz, Oscar and Renggli, Lukas and Rigo, Armin and Verwaest, Toon},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-540-89275-5-7},
isbn = {3540892745},
issn = {03029743},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {123--139},
publisher = {Springer},
title = {{Back to the future in one week - Implementing a smalltalk VM in PyPy}},
url = {http://link.springer.com/content/pdf/10.1007/978-3-540-89275-5.pdf\#page=130},
volume = {5146 LNCS},
year = {2008}
}
@article{Renggli2010,
abstract = {Lint-like program checkers are popular tools that$\backslash$nensure code quality by verifying compliance with$\backslash$nbest practices for a particular programming$\backslash$nlanguage. The proliferation of internal$\backslash$ndomain-specific languages and models, however, poses$\backslash$nnew challenges for such tools. Traditional program$\backslash$ncheckers produce many false positives and fail to$\backslash$naccurately check constraints, best practices, common$\backslash$nerrors, possible optimizations and portability$\backslash$nissues particular to domain-specific languages. We$\backslash$nadvocate the use of dedicated rules to check$\backslash$ndomain-specific practices. We demonstrate the$\backslash$nimplementation of domain-specific rules, the$\backslash$nautomatic fixing of violations, and their$\backslash$napplication to two case-studies: (1) Seaside defines$\backslash$nseveral internal DSLs through a creative use of the$\backslash$nsyntax of the host language; and (2) Magritte adds$\backslash$nmeta-descriptions to existing code by means of$\backslash$nspecial methods. Our empirical validation$\backslash$ndemonstrates that domain-specific program checking$\backslash$nsignificantly improves code quality when compared$\backslash$nwith general purpose program checking.},
author = {Renggli, Lukas and Ducasse, St\'{e}phane and G\^{\i}rba, Tudor and Nierstrasz, Oscar},
doi = {10.1007/978-3-642-13953-6\_12},
isbn = {3642139523},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {Pharo,Squeak},
mendeley-tags = {Pharo,Squeak},
pages = {213--232},
title = {{Domain-specific program checking}},
volume = {6141 LNCS},
year = {2010}
}
@incollection{bergel_stateful_2007,
abstract = {Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports stateful traits. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. Naming conflicts are avoided, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy. \&copy; Springer-Verlag Berlin Heidelberg 2007.},
author = {Bergel, Alexandre and Ducasse, St\'{e}phane and Nierstrasz, Oscar and Wuyts, Roel},
booktitle = {Lecture Notes in Computer Science including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics},
doi = {10.1007/978-3-540-71836-9\_4},
isbn = {9783540718352},
issn = {03029743},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {66--90},
publisher = {Springer},
title = {{Stateful Traits}},
url = {http://scg.unibe.ch/archive/papers/Berg07aStatefulTraits.pdf},
volume = {4406},
year = {2007}
}
@incollection{renggli_magrittemeta-driven_2007,
abstract = {Model-driven engineering is a powerful approach to$\backslash$nbuild large-scale applications. However, an$\backslash$napplication's metamodel often remains static after$\backslash$nthe development phase and cannot be changed unless a$\backslash$nnew development effort occurs. Yet, end users often$\backslash$nneed to rapidly adapt their applications to new$\backslash$nbusiness needs. In many cases, the end users would$\backslash$nknow how to make the required adaptations, if only,$\backslash$nthe application would let them do so. In this paper$\backslash$nwe present how we built a runtime-dynamic$\backslash$nmeta-environment by integrating Magritte, a$\backslash$nself-described metamodel, into Smalltalk's$\backslash$nreflective language model. Our solution offers the$\backslash$nbest of both worlds: developers can develop their$\backslash$napplications using the same tools they were used to,$\backslash$nbut at the same time they gain the power of$\backslash$nmeta-programming. We show in particular that our$\backslash$napproach is adapted to support end user$\backslash$ncustomization of applications: the adaptive model of$\backslash$nMagritte enables to not only describe existing$\backslash$nclasses, but also lets end users build their own$\backslash$nmetamodels on the fly.},
author = {Renggli, Lukas and Ducasse, St\'{e}phane and Kuhn, Adrian},
booktitle = {Model Driven Engineering Languages and Systems},
doi = {10.1007/978-3-540-75209-7\_8},
isbn = {978-3-540-75208-0},
issn = {03029743},
keywords = {Squeak,scg07 scg-pub jb07 snf07 snf-bmcc akuhn fame},
mendeley-tags = {Squeak},
pages = {106--120},
publisher = {Springer},
title = {{Magritte --- A Meta-Driven Approach to Empower Developers and End Users}},
url = {http://scg.unibe.ch/archive/papers/Reng07aMagritte.pdf},
volume = {4735},
year = {2007}
}
@inproceedings{ducasse_supporting_2005,
abstract = {On the one hand, traits are a powerful way of$\backslash$nstructuring classes. Traits support the reuse of$\backslash$nmethod collections over several classes. However,$\backslash$ntraits cannot be used when specifying unanticipated$\backslash$nchanges to an application. On the other hand,$\backslash$nclassboxes are a new module system that supports the$\backslash$nlocal redefinition of classes: a collection of$\backslash$nclasses can be locally extended with variables$\backslash$nand/or methods and the existing clients do not get$\backslash$nimpacted by changes. However, an extension applied$\backslash$nto a class by a classbox cannot be reused for other$\backslash$nclasses. This paper describes how combining Traits$\backslash$nand Classboxes supports the safe introduction of$\backslash$ncrosscutting collaborations: safe because the$\backslash$nexisting clients of the classes do not get impacted,$\backslash$ncrosscutting because collaborations between several$\backslash$nclasses can be put in place in a unanticipated$\backslash$nmanner. In the resulting system, a collaboration is$\backslash$nrepresented by a classbox and a role by a trait.},
author = {Bergel, Alexandre and Ducasse, St\'{e}phane},
booktitle = {Net.ObjectDays (NODE'05)},
isbn = {3885793989},
keywords = {Squeak,snf05 jb06 scg-pub skip-doi alexPub stefPub listic},
mendeley-tags = {Squeak},
pages = {61--75},
title = {{Supporting Unanticipated Changes with Traits and Classboxes}},
url = {http://scg.unibe.ch/archive/papers/Berg05dTraitsClassbox.pdf},
year = {2005}
}
@inproceedings{hofer_design_2006,
author = {Hofer, Christoph and Denker, Marcus and Ducasse, St\'{e}phane},
booktitle = {NODe 2006},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {17--32},
publisher = {GI},
title = {{Design and implementation of a backward-in-time debugger}},
url = {https://hal.inria.fr/inria-00555768/},
year = {2006}
}
@inproceedings{a,
author = {Hirschfeld, R},
booktitle = {Objects, Components, Architectures, Services, and Applications for a Networked Worl(LNCS)},
doi = {10.1007/3-540-36557-5\_17},
issn = {03029743},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {216--232},
title = {{AspectS - Aspect-Oriented Programming with Squeak}},
url = {http://dx.doi.org/10.1007/3-540-36557-5\_17},
year = {2003}
}
@incollection{bergel_domain-specific_2011,
author = {Bergel, Alexandre and Nierstrasz, Oscar and Renggli, Lukas and Ressia, Jorge},
booktitle = {Objects, Models, Components, Patterns},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {68--82},
publisher = {Springer},
title = {{Domain-specific profiling}},
url = {http://link.springer.com/chapter/10.1007/978-3-642-21952-8\_7},
year = {2011}
}
@inproceedings{gaelli_one-method_2004,
abstract = {Although unit testing is essential for programming,$\backslash$ncurrent languages only barely support the developer$\backslash$nin composing unit tests into new ones or in$\backslash$nnavigating between unit tests and their$\backslash$ncorresponding methods under test. We have taken$\backslash$nseveral Smalltalk programs and analyzed the$\backslash$nrelationships between unit tests and methods under$\backslash$ntest, and the re- lationships amongst unit tests.$\backslash$nFirst results indicate that most unit tests can be$\backslash$nseen or at least decomposed into commands which$\backslash$nfocus on single methods, and that large portions of$\backslash$nunit tests overlap each other. But these$\backslash$nrelationships between unit tests and methods under$\backslash$ntest are not reflected in current languages. We$\backslash$ntherefore first conceptually extend the meta-model$\backslash$nof Smalltalk with one-method commands so that unit$\backslash$ntests become both com- posable and navigable. Then$\backslash$nwe introduce a first lightweight implementation of$\backslash$nthis meta model using method comments to$\backslash$ndifferentiate between the several test phases of$\backslash$nexisting XUnit test case methods.},
author = {Gaelli, Markus and Nierstrasz, Oscar and Ducasse, St\'{e}phane},
booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
keywords = {Squeak,snf05 scg-pub skip-doi gaelli jb05},
mendeley-tags = {Squeak},
publisher = {Citeseer},
shorttitle = {One-method commands},
title = {{One-Method Commands: Linking Methods and Their Tests}},
url = {http://scg.unibe.ch/archive/papers/Gael04cLinkingMethodsAndTests.pdf},
year = {2004}
}
@inproceedings{nierstrasz_supporting_2004,
abstract = {In this paper we briefly review various kinds of software changes and the issues that arise from them. As a consequence, we propose research into programming languages with explicit support for representing first-class changes, and for manipulating and merging multiple viewpoints of evolving software systems.},
author = {Nierstrasz, Oscar and Denker, Marcus},
booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
keywords = {Squeak,classboxes,languages,sofware evolution,traits},
mendeley-tags = {Squeak},
number = {October},
pages = {1--5},
title = {{Supporting Software Change in the Programming Language}},
url = {http://scg.unibe.ch/archive/papers/Nier04dRDLchange.pdf},
year = {2004}
}
@inproceedings{a,
abstract = {Weaving is one of the fundamental mechanisms of aspect-oriented systems. A weaver composes different aspects with the base system by determining and adapting all parts where aspect specific elements are needed eventually. At runtime, timeconsuming join point checks are necessary to determine if at a certain join point aspect-specific code needs to be executed. Current technologies enforce such checks even in locations that only temporarily or under restrictive conditions (or even never) execute aspect-specific code. In more complex applications, a large number of these checks fail and just cause a substantial runtime overhead without contributing to the system's overall behavior. The main reason for this flaw is complete weaving, the way how aspects are woven to an application using current technologies. In this paper we discuss the problem of unnecessary join point checks caused by complete weaving. We introduce morphing aspects - incompletely woven aspects in combination with continuous weaving - to overcome the problem of futile join point checks.},
author = {Hanenberg, Stefan and Hirschfeld, Robert and Unland, Rainer},
booktitle = {Proc. 3rd Int' Conf. on Aspect-Oriented Software Development \{(\{AOSD\}-2004)\}},
doi = {http://doi.acm.org/10.1145/976270.976278},
isbn = {1-58113-842-3},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {46--55},
title = {{Morphing aspects: incompletely woven aspects and continuous weaving}},
year = {2004}
}
@inproceedings{a,
abstract = { Squeak is an open, highly-portable Smalltalk implementation whose virtual machine is written entirely in Smalltalk, making it easy to debug, analyze, and change. To achieve practical performance, a translator produces an equivalent C program whose performance is comparable to commercial Smalltalks. Other noteworthy aspects of Squeak include: a compact object format that typically requires only a single word of overhead per object; a simple yet efficient incremental garbage collector for 32-bit direct pointers; efficient bulk- mutation of objects; extensions of BitBlt to handle color of any depth and anti-aliased image rotation and scaling; and real-time sound and music synthesis written entirely in Smalltalk. },
author = {Ingalls, Dan and Kaehler, Ted and Maloney, John and Wallace, Scott and Kay, Alan},
booktitle = {Proc. of the 12th ACM SIGPLAN Conference on Object-oriented Programming, 1997},
doi = {http://doi.acm.org/10.1145/263698.263754},
isbn = {0-89791-908-4},
issn = {0362-1340},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {318--326},
title = {{Back to the future: the story of Squeak, a practical Smalltalk written in itself}},
year = {1997}
}
@inproceedings{robbes_how_2011,
abstract = {The dynamic and reflective features of programming languages are powerful constructs that programmers often mention as extremely useful. However, the ability to modify a program at runtime can be both a boon-in terms of flexibility-, and a curse-in terms of tool support. For instance, usage of these features hampers the design of type systems, the accuracy of static analysis techniques, or the introduction of optimizations by compilers. In this paper, we perform an empirical study of a large Smalltalk codebase- often regarded as the poster-child in terms of availability of these features-, in order to assess how much these features are actually used in practice, whether some are used more than others, and in which kinds of projects. These results are useful to make informed decisions about which features to consider when designing language extensions or tool support.},
author = {Calla\'{u}, Oscar and Robbes, Romain and Tanter, \'{E}ric and R\"{o}thlisberger, David},
booktitle = {Proceeding of the 8th working conference on Mining software repositories - MSR '11},
doi = {10.1145/1985441.1985448},
isbn = {9781450305747},
keywords = {Pharo,Squeak,dynamic languages,smalltalk,static analysis},
mendeley-tags = {Pharo,Squeak},
pages = {23},
shorttitle = {How developers use the dynamic features of program},
title = {{How developers use the dynamic features of programming languages}},
url = {http://dl.acm.org/citation.cfm?id=1985441.1985448},
year = {2011}
}
@inproceedings{a,
abstract = {Writing unit tests for a software system enhances the confidence that a system works as expected. Since time pressure often prevents a complete testing of all application details developers need to know which new tests the system requires. Developers also need to know which existing tests take the most time and slow down the whole development process. Missing feedback about less tested functionality and reasons for long running test cases make it, however, harder to create a test suite that covers all important parts of a software system in a minimum of time. As a result a software system may be inadequately tested and developers may test less frequently. Our approach provides test quality feedback to guide developers in identifying missing tests and correcting low-quality tests. We provide developers with a tool that analyzes test suites with respect to their effectivity (e.g., missing tests) and efficiency (e.g., time and memory consumption). We implement our approach, named Path Map, as an extended test runner within the Squeak Smalltalk IDE and demonstrate its benefits by improving the test quality of representative software systems.},
author = {Perscheid, Michael and Cassou, Damien and Hirschfeld, Robert},
booktitle = {Proceedings - 10th International Conference on Creating, Connecting and Collaborating through Computing, C5 2012},
doi = {10.1109/C5.2012.7},
isbn = {9780769546728},
keywords = {Dynamic Analysis,Squeak,Test Quality Feedback,Unit Tests},
mendeley-tags = {Squeak},
pages = {60--67},
title = {{Test quality feedback improving effectivity and efficiency of unit testing}},
year = {2012}
}
@inproceedings{a,
author = {Thamsen, Lauritz and Gulenko, Anton and Perscheid, Michael and Krahn, Robert and Hirschfeld, Robert and Thomas, David a.},
booktitle = {Proceedings - 10th International Conference on Creating, Connecting and Collaborating through Computing, C5 2012},
doi = {10.1109/C5.2012.9},
isbn = {9780769546728},
keywords = {Collaborative Web Development,JavaScript,Orca,Smalltalk,Squeak},
mendeley-tags = {Squeak},
pages = {45--52},
title = {{Orca: A single-language web framework for collaborative development}},
year = {2012}
}
@inproceedings{a,
abstract = {Active content in multimedia documents helps the reader to grasp the implications of nonlinear and complex systems that are difficult to understand in a text-based description. The readers are able to make their own experiments by changing the underlying rules of these systems. The multimedia authoring environment Sophie has limited capabilities for authoring active dynamic contents. For that reason we integrated a tile scripting system based on Tweak Etoys in Sophie. In SophieScript scripts can be embedded into the text and the reader changes them via direct graphical manipulation. With the implemented tile scripting system the user can easily create dynamic content and, at the same time, make use of the multimedia and text capabilities of Sophie.},
author = {Lincke, Jens and Hirschfeld, Robert and R\"{u}ger, Michael and Masuch, Maic},
booktitle = {Proceedings - 6th International Conference on Creating, Connecting and Collaborating through Computing, C5 2008},
doi = {10.1109/C5.2008.12},
isbn = {0769531156},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {21--28},
title = {{SophieScript - Active content in multimedia documents}},
year = {2008}
}
@inproceedings{thalmann_jam_2006,
abstract = {We propose a music generation software that allows large numbers of users to collaborate. In a virtual world, groups of users generate music simultaneously at different places in a room. This can be realized using OpenAL sound sources. The generated musical pieces have to be modifiable while they are playing and all collaborating users should immediately see and hear the results of such modifications. We are testing these concepts within Croquet by implementing a software called Jam Tomorrow},
author = {Thalmann, Florian and Gaelli, Markus},
booktitle = {Proceedings - Fourth International Conference on Creating, Connecting and Collaborating through Computing, C5 2006},
doi = {10.1109/C5.2006.22},
isbn = {0769525636},
keywords = {Croquet,Squeak},
mendeley-tags = {Croquet,Squeak},
pages = {73--78},
publisher = {IEEE},
shorttitle = {Jam \{Tomorrow\}},
title = {{Jam tomorrow: Collaborative music generation in croquet using OpenAL}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4019379},
year = {2006}
}
@inproceedings{gaelli_idioms_2006,
abstract = {Creating one's own games has been the main motivation for many people to learn programming. But the barrier to learn a general purpose programming language is very high, especially if some positive results can only be expected after having manually written more than 100 lines of code. With this paper we first motivate potential users by showing that one can create classic board- and arcade games like Lights Out, TicTacToe, or Pacman within the playful and constructivist visual learning environment EToys dragging together only a few lines of code. Then we present recurring idioms which helped to develop these games},
author = {Gaelli, Markus and Nierstrasz, Oscar and Stinckwich, Serge},
booktitle = {Proceedings - Fourth International Conference on Creating, Connecting and Collaborating through Computing, C5 2006},
doi = {10.1109/C5.2006.20},
isbn = {0769525636},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {222--229},
publisher = {IEEE},
title = {{Idioms for composing games with EToys}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4019398},
year = {2006}
}
@inproceedings{schwarz_how_2012,
abstract = {Detecting code duplication in large code bases, or even across project$\backslash$nboundaries, is problematic due to the massive amount of data involved.$\backslash$nLarge-scale clone detection also opens new challenges beyond asking for$\backslash$nthe provenance of a single clone fragment, such as assessing the$\backslash$nprevalence of code clones on the entire code base, and their evolution.$\backslash$nWe propose a set of lightweight techniques that may scale up to very$\backslash$nlarge amounts of source code in the presence of multiple versions. The$\backslash$ncommon idea behind these techniques is to use bad hashing to get a quick$\backslash$nanswer. We report on a case study, the Squeaksource ecosystem, which$\backslash$nfeatures thousands of software projects, with more than 40 million$\backslash$nversions of methods, across more than seven years of evolution. We$\backslash$nprovide estimates for the prevalence of type-1, type-2, and type-3$\backslash$nclones in Squeaksource.},
author = {Schwarz, Niko and Lungu, Mircea and Robbes, Romain},
booktitle = {Proceedings - International Conference on Software Engineering},
doi = {10.1109/ICSE.2012.6227097},
isbn = {9781467310673},
issn = {02705257},
keywords = {Clone detection,Pharo,Software ecosystems,Squeak,Squeaksource},
mendeley-tags = {Pharo,Squeak,Squeaksource},
pages = {1289--1292},
publisher = {IEEE Press},
title = {{On how often code is cloned across repositories}},
url = {http://dl.acm.org/citation.cfm?id=2337398},
year = {2012}
}
@inproceedings{schwarz_hot_2012,
abstract = {Code duplication is common in current programming-practice: programmers$\backslash$nsearch for snippets of code, incorporate them into their projects and$\backslash$nthen modify them to their needs. In today's practice, no automated$\backslash$nscheme is in place to inform both parties of any distant changes of the$\backslash$ncode. As code snippets continue to evolve both on the side of the user$\backslash$nand on the side of the author, both may wish to benefit from remote bug$\backslash$nfixes or refinements - authors may be interested in the actual usage of$\backslash$ntheir code snippets, and researchers could gather information on clone$\backslash$nusage. We propose to maintain a link between software clones across$\backslash$nrepositories and outline how the links can be created and maintained.},
author = {Schwarz, Niko},
booktitle = {Proceedings - International Conference on Software Engineering},
doi = {10.1109/ICSE.2012.6227221},
isbn = {9781467310673},
issn = {02705257},
keywords = {Squeak,Squeaksource,clone detection,corrective clone management,software maintenance},
mendeley-tags = {Squeak,Squeaksource},
pages = {1628--1629},
publisher = {IEEE Press},
shorttitle = {Hot clones},
title = {{Hot clones: Combining search-driven development, clone management, and code provenance}},
url = {http://dl.acm.org/citation.cfm?id=2337504},
year = {2012}
}
@inproceedings{ducasse_butterflies:_2005,
abstract = {Understanding sets of classes, or packages, is an important activity in the development and reengineering of large object-oriented systems. Packages represent the coarse grained structure of an application. They are artefacts to deploy and structure software, and therefore more than a simple generalization of classes. The relationships between packages and their contained classes are key in the decomposition of an application and its (re)-modularisation. However, it is difficult to quickly grasp the structure of a package and to understand how a package interacts with the rest of the system. We tackle this problem using butterfly visualizations, i.e., dedicated radar charts built from simple package metrics based on a language-independent meta-model. We illustrate our approach on two applications and show how we can retrieve the relevant characteristics of packages},
author = {Ducasse, St\'{e}phane and Lanza, Michele and Ponisio, Laura},
booktitle = {Proceedings - International Software Metrics Symposium},
doi = {10.1109/METRICS.2005.15},
isbn = {0769523714},
issn = {15301435},
keywords = {Package metrics,Program understanding,Reverse engineering,Software visualization,Squeak},
mendeley-tags = {Squeak},
pages = {45--54},
publisher = {IEEE},
shorttitle = {Butterflies},
title = {{Butterflies: A visual approach to characterize packages}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=1509285},
volume = {2005},
year = {2005}
}
@inproceedings{a,
abstract = {Visualizations of actual run-time data support the comprehension of programs, like examples support the explanation of abstract concepts and principles. Unfortunately, the required run-time analysis is often associated with an inconvenient overhead that renders current tools impractical for frequent use. We propose an interactive approach to collect and present run-time data. An initial shallow analysis provides for immediate access to visualizations of run-time information. As users explore this information, it is incrementally refined on-demand. We present an implementation that realizes our proposed approach and enables developers to instantly explore run-time behavior of selected code entities. We evaluate our interactive approach by measuring time and memory overhead in the context of ten different-sized projects. Our empirical results show that run-time data for an initial overview can be collected in less than 300 milliseconds for 95\% of cases.},
author = {Perscheid, Michael and Steinert, Bastian and Hirschfeld, Robert and Geller, Felix and Haupt, Michael},
booktitle = {Proceedings - Working Conference on Reverse Engineering, WCRE},
doi = {10.1109/WCRE.2010.17},
isbn = {9780769541235},
issn = {10951350},
keywords = {Development environments,Dynamic analysis,Object collaboration,Program comprehension,Squeak,Test cases},
mendeley-tags = {Squeak},
pages = {77--86},
title = {{Immediacy through interactivity: Online analysis of run-time behavior}},
year = {2010}
}
@inproceedings{rothlisberger_autumn_2009,
abstract = {Navigating large software systems is difficult as the various artifacts are distributed in a huge space, while the relationships between different artifacts often remain hidden and obscure. As a consequence, developers using a modern interactive development environment (IDE) are forced to open views on numerous source artifacts to reveal these hidden relationships, leading to a crowded workspace with many opened windows or tabs. Developers often lose the overview in such a cluttered workspace as IDEs provide little support to get rid of unused windows. AutumnLeaves automatically selects windows unlikely for future use to be closed or grayed out while important ones are displayed more prominently. This reduces the number of windows opened at a time and adds structure to the developer's workspace. We validate AutumnLeaves with a benchmark evaluation using recorded navigation data of various developers to determine the prediction quality of the employed algorithms.},
author = {R\"{o}thlisberger, David and Nierstrasz, Oscar and Ducasse, St\'{e}phane},
booktitle = {Proceedings - Working Conference on Reverse Engineering, WCRE},
doi = {10.1109/WCRE.2009.18},
isbn = {9780769538679},
issn = {10951350},
keywords = {Developer activity analysis,Development environments,Productivity,Program comprehension,Software navigation,Squeak},
mendeley-tags = {Squeak},
pages = {237--246},
publisher = {IEEE},
shorttitle = {Autumn leaves},
title = {{Autumn leaves: Curing the window plague in IDEs}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=5328777},
year = {2009}
}
@inproceedings{ducasse_smallwiki:_2005,
abstract = {Wikis are often implemented using string-based$\backslash$napproaches to parse and generate their pages. While$\backslash$nsuch approaches work well for simple wikis, they$\backslash$nhamper the customization and adaptability of wikis$\backslash$nto the variety of end-users when more sophisticated$\backslash$nneeds are required (i.e., different output formats,$\backslash$nuser-interfaces, wiki managment, security policies,$\backslash$n...). In this paper we present SmallWiki, the second$\backslash$nversion of a fully object-oriented implementation of$\backslash$na wiki. SmallWiki is implemented with objects from$\backslash$nthe top to the bottom and it can be customized$\backslash$neasily to accommodate new needs. In addition,$\backslash$nSmallWiki is based on a powerful meta-description$\backslash$ncalled Magritte that allows one to create$\backslash$nuser-interface elements declaratively.},
author = {Ducasse, St\'{e}phane and Renggli, Lukas and Wuyts, Roel},
booktitle = {Proceedings ACM International Symposium on Wikis (WikiSym'05)},
doi = {10.1145/1104973.1104981},
isbn = {1595931112},
keywords = {Squeak,jb06 scg-pub snf-none stefPub moose-pub},
mendeley-tags = {Squeak},
pages = {75--82},
publisher = {ACM},
shorttitle = {SmallWiki},
title = {{SmallWiki --- A Meta-Described Collaborative Content Management System}},
url = {http://scg.unibe.ch/archive/papers/Duca05hSmallwikiWikiSymp05.pdf},
year = {2005}
}
@inproceedings{lienhard_capturing_2006,
author = {van Geet, Joris and Zaidman, Andy},
booktitle = {Proceedings International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2006)},
doi = {10.1109/WCRE.2006.45},
isbn = {0-7695-2719-1},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {October},
pages = {315--315},
title = {{A Lightweight Approach to Determining the Adequacy of Tests as Documentation}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4024010},
year = {2006}
}
@inproceedings{rengglib_seasidemultiple_2004,
abstract = {Developing web applications is difficult since (1)$\backslash$nthe client-server relationship is asymmetric: the$\backslash$nserver cannot update clients but only responds to$\backslash$nclient requests and (2) the navigation facilities of$\backslash$nweb browsers lead to a situation where servers$\backslash$ncannot control the state of the clients.$\backslash$nPage-centric web application frameworks fail to$\backslash$noffer adequate solutions to model control flow at a$\backslash$nhigh-level of abstraction. Developers have to work$\backslash$nmanually around the shortcomings of the HTTP$\backslash$nprotocol. Some approaches offer better abstractions$\backslash$nby composing an application out of components,$\backslash$nhowever they still fail to offer modeling control$\backslash$nflow at a high level. Continuation-based approaches$\backslash$nsolve this problem by providing the facilities to$\backslash$nmodel a control flow over several pages with one$\backslash$npiece of code. However combining multiple flows$\backslash$ninside the same page is difficult. This article$\backslash$npresents Seaside. Seaside is a framework which$\backslash$ncombines an object-oriented approach with a$\backslash$ncontinuation-based one. A Seaside application is$\backslash$nbuilt out of components (i.e., objects) and the$\backslash$nlogic of the application benefits from the$\backslash$ncontinuation-based program flow infrastructure.$\backslash$nSeaside offers a unique way to have multiple control$\backslash$nflows on a page, one for each component. This$\backslash$nenables the developer to write components that are$\backslash$nhighly reusable and that can be used to compose$\backslash$ncomplex web applications with higher quality in less$\backslash$ntime.},
author = {Ducasse, St\'{e}phane and Lienhard, Adrian and Renggli, Lukas},
booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
keywords = {Squeak,scg-pub skip-doi jb05 snf05 stefPub seaside-articl},
mendeley-tags = {Squeak},
pages = {231--257},
title = {{Seaside --- a Multiple Control Flow Web Application Framework}},
url = {http://scg.unibe.ch/archive/papers/Duca04eSeaside.pdf$\backslash$nhttp://www.iam.unibe.ch/publikationen/techreports/2004/iam-04-008},
year = {2004}
}
@inproceedings{a,
author = {Taeumel, Marcel and Felgentreff, Tim and Hirschfeld, Robert},
booktitle = {Proceedings of 6th International Workshop on Context-Oriented Programming - COP'14},
doi = {10.1145/2637066.2637067},
isbn = {9781450328616},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {1--7},
title = {{Applying Data-driven Tool Development to Context-oriented Languages}},
url = {http://dl.acm.org/citation.cfm?id=2637066.2637067},
year = {2014}
}
@incollection{scharli_composable_2004,
abstract = {Given the importance of encapsulation to$\backslash$nobject-oriented programming, it is surprising to$\backslash$nnote that mainstream object-oriented languages offer$\backslash$nonly limited and fixed ways of encapsulating$\backslash$nmethods. Typically one may only address two$\backslash$ncategories of clients, users and heirs, and one must$\backslash$nbind visibility and access rights at an early stage.$\backslash$nThis can lead to inflexible and fragile code as well$\backslash$nas clumsy workarounds. We propose a simple and$\backslash$ngeneral solution to this problem in which$\backslash$nencapsulation policies can be specified separately$\backslash$nfrom implementations. As such they become$\backslash$nfirst-class composable entities that can be reused$\backslash$nby different classes. We present a detailed analysis$\backslash$nof the problem with encapsulation and visibility$\backslash$nmechanisms in mainstream OO languages, we introduce$\backslash$nour approach in terms of a simple model, and we$\backslash$nevaluate how our approach compares with existing$\backslash$napproaches. We also assess the impact of$\backslash$nincorporating encapsulation policies into Smalltalk$\backslash$nand discuss some implementation issues.},
author = {Sch\"{a}rli, Nathanael and Ducasse, St\'{e}phane and Nierstrasz, Oscar and Wuyts, Roel},
booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'04)},
doi = {10.1007/b98195},
isbn = {978-3-540-22159-3},
issn = {1611-3349},
keywords = {Squeak,snf04 scg-pub jb04 scg-traits stefPub schaerli},
mendeley-tags = {Squeak},
pages = {26--50},
publisher = {Springer},
title = {{Composable Encapsulation Policies}},
url = {http://scg.unibe.ch/archive/papers/Scha04aEncapsulationPolicies.pdf},
volume = {3086},
year = {2004}
}
@article{rothlisberger_combining_2007,
author = {R\"{o}thlisberger, David and Nierstrasz, Oscar},
journal = {Proceedings of FAMOOSr},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {20},
title = {{Combining Development Environments with Reverse Engineering}},
url = {http://www.researchgate.net/profile/David\_Roethlisberger/publication/240804387\_Combining\_Development\_Environments\_with\_Reverse\_Engineering/links/5437f79f0cf2d5fa292ba03a.pdf},
volume = {2007},
year = {2007}
}
@incollection{bergel_classboxes:_2003,
abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
author = {Bergel, Alexandre and Ducasse, St\'{e}phane and Wuyts, Roel},
booktitle = {Proceedings of Joint Modular Languages Conference JMLC03},
doi = {10.1007/b12023},
editor = {B\"{o}sz\"{o}rm\'{e}nyi, L\'{a}szl\'{o} and Schojer, Peter},
isbn = {978-3-540-40796-6},
issn = {03029743},
keywords = {Compilers,Interpreters,Logics and Meanings of Programs,Operating Systems,Programming Languages,Programming Techniques,Squeak,class ex,language design,method lookup,modules,selector namespace,smalltalk,software engineering,tension},
mendeley-tags = {Squeak},
number = {2789},
pages = {122--131},
publisher = {Springer Berlin Heidelberg},
series = {Lecture \{Notes\} in \{Computer\} \{Science\}},
shorttitle = {Classboxes},
title = {{Classboxes: A Minimal Module Model Supporting Local Rebinding}},
url = {http://scg.unibe.ch/archive/papers/Berg03aClassboxes.pdf},
volume = {2789},
year = {2003}
}
@inproceedings{a,
abstract = {Teaching pupils the ideas behind objects in programming languages can be difficult since these concepts are mostly abstract and not comprehensible at first sight. Etoys as a visual programming environment counters such issues by introducing visible objects and simple tiles for programming them. However, all of these objects can only be experienced virtually on the screen. This paper presents PhidgetLab, a programming environment for electronic components (Phidgets) realised on top of the Etoys environment. PhidgetLab helps crossing the border from virtual to real-world objects. Pupils interact with tangible objects that are seamlessly connected to the digital world. PhidgetLab was evaluated in a case study with 22 pupils, following the principles of the Design Thinking methodology and comprised the realisation of five prototypes within a short period of time.},
author = {Haupt, Michael and Perscheid, Michael and Hirschfeld, Robert},
booktitle = {Proceedings of the 15th Annual SIGCSE Conference on Innovation and Technology in Computer Science Education},
doi = {10.1145/1822090.1822112},
isbn = {9781605588209},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {73--77},
title = {{PhidgetLab: crossing the border from virtual to real-world objects}},
url = {http://dl.acm.org/citation.cfm?id=1822112},
year = {2010}
}
@inproceedings{a,
abstract = {ContextL is an extension to the Common Lisp Object System that allows for Context-oriented Programming. It provides means to associate partial class and method definitions with layers and to activate and deactivate such layers in the control flow of a running program. When a layer is activated, the partial definitions become part of the program until this layer is deactivated. This has the effect that the behavior of a program can be modified according to the context of its use without the need to mention such context dependencies in the affected base program. We illustrate these ideas by providing different UI views on the same object while, at the same time, keeping the conceptual simplicity of object-oriented programming that objects know by themselves how to behave, in our case how to display themselves. These seemingly contradictory goals can be achieved by separating class definitions into distinct layers instead of factoring out the display code into different classes.},
author = {Costanza, Pascal and Hirschfeld, Robert},
booktitle = {Proceedings of the 2005 conference on Dynamic languages symposium - DLS '05},
doi = {10.1145/1146841.1146842},
isbn = {1595932836},
keywords = {Squeak,context-oriented programming,dynamic scope,layers,views},
mendeley-tags = {Squeak},
pages = {1--10},
title = {{Language constructs for context-oriented programming}},
url = {http://portal.acm.org/citation.cfm?doid=1146841.1146842},
year = {2005}
}
@inproceedings{rothlisberger_feature_2007,
author = {R\"{o}thlisberger, David and Greevy, Orla and Nierstrasz, Oscar},
booktitle = {Proceedings of the 2007 international Conference on Dynamic Languages: in Conjunction with the 15th international Smalltalk Joint Conference 2007},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {August},
pages = {25--31},
publisher = {ACM},
title = {{Feature Driven Browsing}},
url = {http://dl.acm.org/citation.cfm?id=1352684},
year = {2007}
}
@inproceedings{renggli_transactional_2007,
author = {Renggli, Lukas and Nierstrasz, Oscar},
booktitle = {Proceedings of the 2007 international conference on Dynamic languages: in conjunction with the 15th International Smalltalk Joint Conference 2007},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {August},
pages = {25--31},
publisher = {ACM},
title = {{Transactional Memory for Smalltalk}},
url = {http://dl.acm.org/citation.cfm?id=1352692},
year = {2007}
}
@inproceedings{rothlisberger_querying_2008,
author = {R\"{o}thlisberger, David},
booktitle = {Proceedings of the 2008 workshop on Query Technologies and Applications for Program Comprehension (QTAPC 2008)},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Querying runtime information in the ide}},
url = {http://www.researchgate.net/profile/David\_Roethlisberger/publication/229037623\_Querying\_runtime\_information\_in\_the\_ide/links/02e7e532bb2a852fda000000.pdf},
year = {2008}
}
@inproceedings{lienhard_identifying_2005,
abstract = {Traits are basically mixins or interfaces but with method bodies. In languages that support traits, classes are composed out of traits. There are two main advantages with traits. Firstly, decomposing existing classes into traits from which they can be recomposed improves the factoring of hierarchies. Secondly it increases the library reuse potential by providing more reusable traits. Identifying traits and decomposing class hierarchies into traits is therefore an important and challenging task to facilitate maintainability and evolution. In this paper we present how we use Formal Concept Analysis to identify traits in inheritance hierarchies. Our approach is two-staged: first we identify within a hierarchy maximal groups of methods that have a set of classes in common, second we cluster cohesive groups of methods based on method invocations as potential traits. We applied our approach on two significant hierarchies and compare our results with the manual refactorization of the same code which was done by the authors of traits.},
author = {Lienhard, Adrian and Ducasse, St\'{e}phane and Ar\'{e}valo, Gabriela},
booktitle = {Proceedings of the 20th IEEE/ACM international Conference on Automated software engineering SE - ASE '05},
doi = {10.1145/1101908.1101921},
isbn = {1-58113-993-4},
keywords = {Squeak,formal\_concept\_analysis},
mendeley-tags = {Squeak},
pages = {66--75},
publisher = {ACM},
title = {{Identifying traits with formal concept analysis}},
url = {http://portal.acm.org/citation.cfm?id=1101908.1101921$\backslash$nciteulike-article-id:8423351$\backslash$nhttp://dx.doi.org/10.1145/1101908.1101921},
year = {2005}
}
@inproceedings{denker_supporting_2007,
abstract = {The dynamic analysis approach to feature$\backslash$nidentification describes a technique for capturing$\backslash$nfeature behavior and mapping it to source code.$\backslash$nMajor drawbacks of this approach are (1) large$\backslash$namounts of data and (2) lack of support for$\backslash$nsub-method elements. In this paper we propose to$\backslash$nleverage sub-method reflection to identify and model$\backslash$nfeatures. We perform an on-the-fly analysis$\backslash$nresulting in annotating the operations participating$\backslash$nin a feature's behavior with meta-data.The primary$\backslash$nadvantage of our annotation approach is that we$\backslash$nobtain a fine-grained level of granularity while at$\backslash$nthe same time eliminating the need to retain and$\backslash$nanalyze large traces for feature analysis.},
author = {Denker, Marcus and Greevy, Orla and Nierstrasz, Oscar},
booktitle = {Proceedings of the 3rd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2007)},
issn = {1872-5392},
keywords = {Squeak,scg07 scg-pub skip-doi snf08 jb08 reflectivity},
mendeley-tags = {Squeak},
pages = {29--33},
publisher = {Technische Universiteit Delft},
title = {{Supporting Feature Analysis with Runtime Annotations}},
url = {http://scg.unibe.ch/archive/papers/Denk07dFeatureAnnotationPCODA.pdf$\backslash$nhttp://swerl.tudelft.nl/bin/view/Main/PCODA2007},
year = {2007}
}
@inproceedings{ducasse_transform_2000,
address = {Irsee, Germany},
author = {Ducasse, St\'{e}phane and Nierstrasz, Oscar and Demeyer, Serge},
booktitle = {Proceedings of the 5th European Conference on Pattern Languages of Programms},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {219--252},
publisher = {Universit\"{a}tsverlag Konstanz},
title = {{Transform Conditionals to Polymorphism}},
url = {http://hillside.net/europlop/HillsideEurope/Papers/EuroPLoP2000/2000\_DucasseEtAl\_TransformConditionals.pdf},
year = {2000}
}
@inproceedings{ducasse_tie_2000,
address = {Irsee, Germany},
author = {Ducasse, St\'{e}phane and Demeyer, Serge and Nierstrasz, Oscar},
booktitle = {Proceedings of the 5th European Conference on Pattern Languages of Programms},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {209--218},
publisher = {Universit\"{a}tsverlag Konstanz},
title = {{Tie Code And Questions: a Reengineering Pattern}},
url = {http://hillside.net/europlop/HillsideEurope/Papers/EuroPLoP2000/2000\_DucasseEtAl\_TieCodeAndQuestions.pdf},
year = {2000}
}
@inproceedings{a,
author = {Steinert, Bastian and Cassou, Damien and Hirschfeld, Robert},
booktitle = {Proceedings of the 8th symposium on Dynamic languages},
doi = {10.1145/2384577.2384591},
isbn = {978-1-4503-1564-7},
issn = {15232867},
keywords = {Squeak,continuous testing,continuous versioning,debugging,evolution,explore-first programming,fault localization,prototyping},
mendeley-tags = {Squeak},
pages = {107--118},
title = {{CoExist: Overcoming Aversion to Change - Preserving Immediate Access to Source Code and Run-time Information of Previous Development States}},
url = {http://doi.acm.org/10.1145/2384577.2384591},
year = {2012}
}
@inproceedings{a,
author = {Taeumel, Marcel and Steinert, Bastian and Hirschfeld, Robert},
booktitle = {Proceedings of the ACM international symposium on New ideas, new paradigms, and reflections on programming and software},
doi = {10.1145/2384592.2384604},
isbn = {978-1-4503-1562-3},
keywords = {Squeak,concurrent views,dynamic analysis,navigation,program comprehension,programming environments,source code},
mendeley-tags = {Squeak},
pages = {117--126},
title = {{The VIVIDE programming environment: connecting run-time information with programmers' system knowledge}},
url = {http://doi.acm.org/10.1145/2384592.2384604},
year = {2012}
}
@inproceedings{robbes_how_2012,
abstract = {When the Application Programming Interface (API) of a framework or library changes, its clients must be adapted. This change propagation---known as a ripple effect---is a problem that has garnered interest: several approaches have been proposed in the literature to react to these changes. Although studies of ripple effects exist at the single system level, no study has been performed on the actual extent and impact of these API changes in practice, on an entire software ecosystem associated with a community of developers. This paper reports on an empirical study of API deprecations that led to ripple effects across an entire ecosystem. Our case study subject is the development community gravitating around the Squeak and Pharo software ecosystems: seven years of evolution, more than 3,000 contributors, and more than 2,600 distinct systems. We analyzed 577 methods and 186 classes that were deprecated, and answer research questions regarding the frequency, magnitude, duration, adaptation, and consistency of the ripple effects triggered by API changes.},
author = {Robbes, Romain and Lungu, Mircea and R\"{o}thlisberger, David},
booktitle = {Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering},
doi = {10.1145/2393596.2393662},
isbn = {978-1-4503-1614-9},
keywords = {Mining software repositories,Pharo,Squeak,ecosystems,empirical studies},
mendeley-tags = {Pharo,Squeak},
pages = {56:1--56:11},
publisher = {ACM},
shorttitle = {How do developers react to api deprecation?},
title = {{How Do Developers React to API Deprecation?: The Case of a Smalltalk Ecosystem}},
url = {http://doi.acm.org/10.1145/2393596.2393662},
year = {2012}
}
@inproceedings{markus_gaelli_test_2003,
abstract = {While assertions of Design by Contract from Eiffel$\backslash$nfound its way into the language-definitions of$\backslash$nPython and of Java SDK 1.4, current object-oriented$\backslash$nlanguages do not make the concepts of unit-testing$\backslash$nexplicit in their definitions or meta-models. Not$\backslash$nhaving support of unit-testing in a programming$\backslash$nlanguage makes it harder to compose and re-compose$\backslash$ntest-scenarios and tests. We propose, that an$\backslash$nobject-oriented language should include explicit$\backslash$nconcepts for example objects, example methods and$\backslash$ninstance-specific assertions. This concepts ease the$\backslash$ncomposition of complex test-scenarios, they help to$\backslash$nrefactor the program with the tests and also to keep$\backslash$nthe duration of the tests as low and the coverage of$\backslash$nthe tests as high as possible.},
address = {Darmstadt, Germany},
author = {Gaelli, Markus},
booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
doi = {10.1007/b98806},
isbn = {978-3-540-22405-1},
keywords = {Squeak,snf03 jb-none scg-pub gaelli},
mendeley-tags = {Squeak},
pages = {143--153},
publisher = {Springer},
title = {{Test composition with example objects and example methods.}},
url = {http://scg.unibe.ch/archive/papers/Gael03aTestComposition.pdf},
volume = {3013},
year = {2003}
}
@inproceedings{schaerli_nathanael_open_2003,
abstract = {Current languages contain visibility mechanisms such$\backslash$nas private, protected, or public to control who can$\backslash$nsee what. However, these visibility mechanisms are$\backslash$nfixed once for all. Moreover, they do not solve all$\backslash$nproblems related to the visibility, and are$\backslash$ntypically of a static nature. In this position paper$\backslash$nwe present an open and uniform way of dealing with$\backslash$nvisibility and introduce surfaces: i.e., list of$\backslash$nmethods that control the way the behavior of an ob$\backslash$nject is accessible. We introduce two problems that$\backslash$nother visibility mechanisms cannot solve, and show$\backslash$nhow surfaces can.},
address = {Darmstadt, Germany},
author = {Ducasse, St\'{e}phane and Sch\"{a}rli, Nathanael and Wuyts, Roel},
booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
keywords = {Squeak,snf03 scg-pub skip-doi jb03 stefPub schaerli},
mendeley-tags = {Squeak},
publisher = {Springer},
title = {{Open Surfaces for Controlled Visibility}},
url = {http://scg.unibe.ch/archive/papers/Duca03bSurfaces.pdf},
volume = {3},
year = {2003}
}
@inproceedings{schaerli_classes_2002,
address = {M\'{a}laga, Spain},
author = {Schaerli, Nathanael and Ducasse, St\'{e}phane and Nierstrasz, Oscar},
booktitle = {Proceedings of The Inheritance Workshop at ECOOP 2002},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {82--88},
publisher = {Springer},
title = {{Classes= traits+ states+ glue}},
year = {2002}
}
@inproceedings{gaelli_composing_2006,
abstract = {The testability of a software component is the ability of the software to reveal its faults. In the development of high reliability systems, testability is an important quality attribute for guiding architecture decisions. The reuse of assets in a software product line propagates defects as readily as correct code. The strategic levels of reuse in a product line produce a high level of inter-dependency among the products in the product line that support this propagation. The increased frequency with which product line components are executed and the range of inputs over which they operate influence the amount of testing required to achieve specific levels of reliability. In this paper we begin the definition of a reasoning framework for testability by considering the characteristics of a product line that influence our view of how testable a component is. Keywords: testability, reachability, software product line},
author = {Mcgregor, John D},
booktitle = {Proceedings of the International Workshop on Software Product Line Testing},
keywords = {Software product line,Squeak,Testability},
mendeley-tags = {Squeak},
pages = {1--7},
publisher = {Citeseer},
title = {{Reasoning about the Testability of Product Line Components}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.391\&rep=rep1\&type=pdf\#page=22},
year = {2005}
}
@inproceedings{a,
abstract = {This position paper proposes the exploitation of$\backslash$ntype feedback mechanisms, or more precisely,$\backslash$npolymorphic inline caches, for purely interpreting$\backslash$nimplementations of object-oriented programming$\backslash$nlanguages. Using Squeak's virtual machine as an$\backslash$nexample, polymorphic inline caches are discussed as$\backslash$nan alternative to global caching. An implementation$\backslash$nproposal for polymorphic inline caches in the Squeak$\backslash$nvirtual machine is presented, and possible future$\backslash$napplications for online optimization are outlined.},
author = {Haupt, Michael and Hirschfeld, Robert and Denker, Marcus},
booktitle = {Proceedings of the Second Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS'2007), ECOOP Workshop},
issn = {1436-9915},
keywords = {Squeak,scg07 scg-pub skip-doi jb08 snf07},
mendeley-tags = {Squeak},
pages = {17--22},
title = {{Type feedback for bytecode interpreters}},
url = {http://scg.unibe.ch/archive/papers/Haup07aPIC.pdf},
year = {2007}
}
@inproceedings{black_traits:_2004,
abstract = {Traits are an object-oriented programming language construct that allow groups of methods to be named and reused in arbitrary places in an inheritance hierarchy. Classes can use methods from traits as well as defining their own methods and instance variables. Traits thus enable a new style of programming, in which traits rather than classes are the primary unit of reuse. However, the additional sub-structure provided by traits is always optional: a class written using traits can also be viewed as a flat collection of methods, with no change in its semantics. This paper describes the tool that supports these two alternate views of a class, called the traits browser, and the programming methodology that we are starting to develop around the use of traits.},
author = {a.P. Black and Scharli, N},
booktitle = {Proceedings. 26th International Conference on Software Engineering},
doi = {10.1109/ICSE.2004.1317489},
isbn = {0-7695-2163-0},
issn = {0270-5257},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {676--686},
publisher = {IEEE Computer Society},
shorttitle = {Traits},
title = {{Traits: tools and methodology}},
url = {http://dl.acm.org/citation.cfm?id=999471},
year = {2004}
}
@inproceedings{a,
abstract = { Change can be observed in our environment and in the technology we build. While changes in the environment happen continuously and implicitly, our technology has to be kept in sync with the changing world around it. Although for some of the changes we can prepare, for most of them we cannot. This is especially true for next generation mobile communication systems that are expected to support the creation of a ubiquitous society where virtually everything is connected and made available within an organic information network. Resources frequently join or leave the network, new types of media or new combinations of existing ones are used to interact and cooperate, and services are tailored to preferences and needs of individual customers to better meet their needs. We outline our research in the area of dynamic service adaptation to provide concepts and technologies allowing for such environments.},
author = {Hirschfeld, Robert and Kawamura, Katsuya},
booktitle = {Software - Practice and Experience},
doi = {10.1002/spe.766},
isbn = {0-7695-2087-1},
issn = {00380644},
keywords = {Aspect-oriented programming,DSA,Dynamic AOP,Dynamic service adaptation,Squeak},
mendeley-tags = {Squeak},
pages = {1115--1131},
title = {{Dynamic service adaptation}},
volume = {36},
year = {2006}
}
@inproceedings{nierstrasz_revival_2005,
abstract = {The programming languages of today are stuck in a deep rut that has developed over the past 50 years. Although we are faced with new challenges posed by enormous advances in hardware and internet technology, we continue to struggle with old-fashioned languages based on rigid, static, closed-world file-based views of programming. We argue the need for a new class of dynamic languages that support a view of programming as constant evolution of living and open software models. Such languages would require features such as dynamic first-class namespaces, explicit meta-models, optional, pluggable type systems, and incremental compilation of running software systems.},
author = {Nierstrasz, Oscar and Bergel, Alexandre and Denker, Marcus and Ducasse, St\'{e}phane and Wuyts, Roel},
booktitle = {Software Composition},
doi = {10.1007/11550679\_1},
isbn = {3540287485},
issn = {03029743},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {1--13},
publisher = {Springer},
title = {{On the Revival of Dynamic Languages}},
url = {http://www.springerlink.com/index/5kyfv61vjdww2dw8.pdf},
volume = {3628},
year = {2005}
}
@inproceedings{hirschfeld2005reflective,
author = {Hirschfeld, Robert and L\"{a}mmel, Ralf},
booktitle = {Software, IEE Proceedings-},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {1},
organization = {IET},
pages = {38--51},
title = {{Reflective designs}},
volume = {152},
year = {2005}
}
@inproceedings{a,
abstract = {This workshop will advance the field of AOSD language design by emphasizing the need to understand the practical consequences of design decisions on the software engineering properties of aspect-oriented software. In particular, it will help language designers understand and evaluate the tradeoffs entailed by aspect language features, and address the need for consistent language design with respect to composability of language constructs and features.},
author = {Kojarski, Sergei and Lieberherr, Karl and Lorenz, David H and Hirschfeld, Robert},
booktitle = {SPLAT: Software engineering Properties of Languages for Aspect Technologies},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Aspectual Reflection}},
url = {http://www.daimi.au.dk/~eernst/splat03/papers/Sergei\_Kojarski.ps},
year = {2003}
}
@inproceedings{a,
author = {Kowark, Thomas},
booktitle = {Structure},
doi = {10.1145/1735935.1735951},
isbn = {9781605588995},
keywords = {Squeak,automatic schema creation,impedance mismatch,object-relational mapping},
mendeley-tags = {Squeak},
pages = {1--15},
title = {{Object-Relational Mapping with SqueakSave}},
year = {2009}
}
@inproceedings{rothlisberger_exploiting_2008,
author = {Group, Software Composition},
booktitle = {The 16th IEEE International Conference on Program Comprehension},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {63--72},
publisher = {IEEE},
title = {{Hermion - Exploiting Runtime Information in the IDE}},
url = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4556118},
year = {2008}
}
@inproceedings{a,
abstract = {The way teams use virtual collaboration tools, such as wikis, email systems, social networks, or version control systems can provide indicators for the success or failure of projects. We previously created a platform that allows to collect and analyze these virtual collaboration activities during project runtime in a non-interfering manner. In this paper, we provide a formal definition of collaboration patterns to enable sharing of beneficial or detrimental collaboration behavior amongst scientist and practitioners. We further define a mapping from collaboration pattern descriptions to SPARQL queries that allows to automatically test other projects for occurrences of the described behavior. By that, we provide a research tool that is able to stimulate relevant and rigorous findings in empirical engineering research and lead to the creation of a shared repository of patterns that reflect best practices in virtual team collaboration.},
author = {Kowark, Thomas and Dobrigkeit, Philipp and Zeier, Alexander},
booktitle = {The 5th International Conference on New Trends in Information Science and Service Science},
doi = {10.1007/978-3-642-31991-4},
isbn = {978-1-4577-0665-3},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {346--351},
title = {{Towards a shared repository for patterns in virtual team collaboration}},
url = {http://link.springer.com/chapter/10.1007/978-3-642-31991-4\_14$\backslash$nhttp://link.springer.com.ezproxy.is.ed.ac.uk/chapter/10.1007/978-3-642-31991-4\_14$\backslash$nhttp://link.springer.com/content/pdf/10.1007\%2F978-3-642-31991-4\_14.pdf},
volume = {2},
year = {2011}
}
@article{achermann_calculus_2005,
abstract = {Although the term software component has become commonplace, there is no universally accepted definition of the term, nor does there exist a common foundation for specifying various kinds of components and their compositions. We propose such a foundation. The Piccola calculus is a process calculus, based on the asynchronous ??-calculus, extended with explicit namespaces. The calculus is high level, rather than minimal, and is consequently convenient for expressing and reasoning about software components, and different styles of composition. We motivate and present the calculus, and outline how it is used to specify the semantics of Piccola, a small composition language. We demonstrate how the calculus can be used to simplify compositions by partial evaluation, and we briefly outline some other applications of the calculus to reasoning about compositional styles. ?? 2004 Elsevier B.V. All rights reserved.},
author = {Achermann, Franz and Nierstrasz, Oscar},
doi = {10.1016/j.tcs.2004.09.022},
issn = {03043975},
journal = {Theoretical Computer Science},
keywords = {Process calculi,Software architecture,Software components,Squeak},
mendeley-tags = {Squeak},
number = {2-3},
pages = {367--396},
title = {{A calculus for reasoning about software composition}},
url = {http://www.sciencedirect.com/science/article/pii/S0304397504006450},
volume = {331},
year = {2005}
}
@incollection{denker_meta_2008,
abstract = {Behavioral reflection is crucial to support for example functional upgrades, on-the-fly debugging, or monitoring critical applications. However the use of reflective features can lead to severe problems due to infinite metacall recursion even in simple cases. This is especially a problem when reflecting on core language features since there is a high chance that such features are used to implement the reflective behavior itself. In this paper we analyze the problem of infinite meta-object call recursion and solve it by providing a first class representation of meta-level execution: at any point in the execution of a system it can be determined if we are operating on a meta-level or base level so that we can prevent infinite recursion. We present how meta-level execution can be represented by a meta-context and how reflection becomes context-aware. Our solution makes it possible to freely apply behavioral reflection even on system classes: the meta-context brings stability to behavioral reflection. We validate the concept with a robust implementation and we present benchmarks.},
author = {Denker, Marcus and Suen, Mathieu and Ducasse, St\'{e}phane},
booktitle = {Tools Europe 2008},
doi = {10.1007/978-3-540-69824-1\_13},
isbn = {9783540698241},
issn = {18651348},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {218--237},
publisher = {Springer},
title = {{The Meta in Meta-object Architectures}},
url = {http://www.iam.unibe.ch/~scg/Archive/Papers/Denk08bMetaContextLNBIP.pdf},
volume = {11},
year = {2008}
}
@article{hirschfeld2008dynamic,
author = {Hirschfeld, Robert},
journal = {Towards 4G Technologies: Services with Initiative},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {191--209},
publisher = {Wiley Online Library},
title = {{Dynamic Adaptation--Changing Services at Run Time}},
year = {2008}
}
@inproceedings{bergel_classbox_2003,
abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
address = {Darmstadt, Germany},
author = {Bergel, Alexandre and Stephane, Ducasse and Roel, Wuyts},
booktitle = {Ukpmc.Ac.Uk},
keywords = {Squeak,class ex-,language design,method lookup,modules,selector namespace,smalltalk,tension},
mendeley-tags = {Squeak},
pages = {1--10},
publisher = {Springer},
title = {{The Classbox Module System}},
url = {http://ukpmc.ac.uk/abstract/CIT/631162},
volume = {3},
year = {2003}
}
@article{a,
author = {Hirschfeld, Robert and Wagner, Matthias and Gybels, Kris},
journal = {Unanticipated Software Evolution},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Assisting System Evolution: A Smalltalk Retrospective}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.7444\&amp;rep=rep1\&amp;type=pdf},
year = {2002}
}
@inproceedings{kuhn_composing_2008,
abstract = {As object-oriented languages are extended with novel modularization mechanisms, better underlying models are required to implement these high-level features. This paper describes Cell, a language model that builds on delegation-based chains of object fragments. Composition of groups of cells is used: 1) to represent objects, 2) to realize various forms of method lookup, and 3) to keep track of method references. A running prototype of Cell is provided and used to realize the basic kernel of a Smalltalk system. The paper shows, using several examples, how higher-level features such as traits can be supported by the lower-level model.},
author = {Kuhn, Adrian and Nierstrasz, Oscar},
booktitle = {VMIL '08: Proceedings of the 2nd Workshop on Virtual Machines and Intermediate Languages for emerging modularization mechanisms},
doi = {10.1145/1507504.1507505},
isbn = {978-1-60558-384-6},
keywords = {Squeak},
mendeley-tags = {Squeak},
pages = {1--12},
publisher = {ACM},
title = {{Composing new abstractions from object fragments}},
url = {http://dx.doi.org/10.1145/1507504.1507505},
year = {2008}
}
@inproceedings{a,
abstract = {Most of all software systems have to be changed after their initial deployment. This is not only because of changing knowledge and expectations about our domains and systems, but also because of the continuous change of the environment itself. While changes in the environment happen implicitly, we need to explicitly keep our technology in sync with the changing world around it. This is especially true for next generation mobile communication systems which we expect to be open to third-party service providers, allowing them to offer services on a variety of service platforms. Not all of these services to be offered will match with all of the platforms. Adjustments and extensions need to be made to offer a pleasant service experience. Research on dynamic service adaptation provides concepts and technologies needed to perform such changes late in a system’s lifecycle, possibly on demand, at runtime, without disruption of service.},
author = {Hirschfeld, Robert and Kawamura, Katsuya and Berndt, Hendrik},
booktitle = {Wireless On-Demand Network Systems},
issn = {03029743},
keywords = {Squeak,runtime evolution},
mendeley-tags = {Squeak},
pages = {227--240},
title = {{Dynamic Service Adaptation for Runtime System Extensions}},
year = {2004}
}
@inproceedings{nierstrasz_analyzing_2006,
abstract = {Software systems need to continuously change to remain useful. Change appears in several forms and needs to be accommodated at different levels. We propose ChangeBoxes as a mechanism to encapsulate, manage, analyze and exploit changes to software systems. Our thesis is that only by making change explicit and manipulable can we enable the software developer to manage software change more effectively than is currently possible. Furthermore we argue that we need new insights into assessing the impact of changes and we need to provide new tools and techniques to manage them. We report on the results of some initial prototyping efforts, and we outline a series of research activities that we have started to explore the potential of ChangeBoxes.},
author = {Nierstrasz, Oscar and Denker, Marcus},
booktitle = {Workshop on Revival of Dynamic Languages (co-located with ECOOP'06)},
keywords = {Squeak},
mendeley-tags = {Squeak},
number = {July},
pages = {1--9},
title = {{Analyzing, Capturing and Taming Software Change}},
url = {http://scg.unibe.ch/archive/papers/Nier06bRDL06ACTSC.pdf},
year = {2006}
}
@inproceedings{a,
author = {Felgentreff, Tim and Pape, Tobias and Wassermann, Lars and Hirschfeld, Robert and Bolz, Carl Friedrich},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Towards Reducing the Need for Algorithmic Primitives in Dynamic Language VMs Through a Tracing JIT}}
}
@inproceedings{a,
author = {Felgentreff, Tim and Perscheid, Michael and Hirschfeld, Robert},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Constraining Timing-dependent Communication for Debugging Non-deterministic Failures}}
}
@inproceedings{a,
author = {Hirschfeld, Robert and Costanza, Pascal and Nierstrasz, Oscar},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Context-oriented Programming}}
}
@inproceedings{a,
author = {Graber, Maria and Felgentreff, Tim and Hirschfeld, Robert and Borning, Alan},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Solving Interactive Logic Puzzles With Object-Constraints: An Experience Report Using Babelsberg/S for Squeak/Smalltalk}}
}
@inproceedings{a,
author = {Kirilichev, Vasily and Seckler, Eric and Siegmund, Benjamin and Perscheid, Michael and Hirschfeld, Robert},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Stepwise Back-in-time Debugging}}
}
@inproceedings{a,
author = {Taeumel, Marcel},
doi = {10.1145/2661136.2661150},
isbn = {9781450332101},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Interleaving of Modification and Use in Dataflow-driven Tool Development}},
year = {2014}
}
@inproceedings{a,
author = {Seckler, Eric and Hirschfeld, Robert},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Archipelago: A Research Platform for Component Interaction in Distributed Applications}}
}
@inproceedings{a,
author = {Felgentreff, Tim and Millstein, Todd and Borning, Alan},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Developing a formal semantics for Babelsberg: A step-by-step approach}}
}
@inproceedings{a,
author = {Hirschfeld, Robert and Haupt, Michael and R\"{u}ger, Michael and Br\"{u}nn, Patrick and Esterlu\ss, Ronny and Holz, Norman and Knebel, Kerstin and Timm, Robert},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{SophieServer - The Future of Reading}}
}
@inproceedings{a,
author = {Freudenberg, Bert and Ingalls, Dan and Felgentreff, Tim and Pape, Tobias and Hirschfeld, Robert},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{SqueakJS - A Modern and Practical Smalltalk That Runs in Any Browser}}
}
@inproceedings{a,
author = {Hirschfeld, Robert and Hanenberg, Stefan},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{OPEN\_aspects}}
}
@inproceedings{a,
author = {Felgentreff, Tim and Borning, Alan and Hirschfeld, Robert},
doi = {10.5381/jot.2014.13.4.a1},
isbn = {9783869562650},
issn = {16601769},
keywords = {Cons,Constraints,Object Constraint Programming,Squeak},
mendeley-tags = {Squeak},
number = {818},
title = {{Babelsberg : Specifying and Solving Constraints on Object Behavior}}
}
@inproceedings{a,
author = {Steinert, Bastian and Taeumel, Marcel and Lincke, Jens and Pape, Tobias and Hirschfeld, Robert},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{CodeTalk-Conversations About Code}}
}
@inproceedings{scharli_partial_2001,
address = {Vienna, Austria},
author = {Sch\"{a}rli, Nathanael and Achermann, Franz},
keywords = {Squeak},
mendeley-tags = {Squeak},
month = sep,
title = {{Partial Evaluation of Inter-Language Wrappers}},
year = {2001}
}
@article{rothlisberger_embedding_2008,
author = {R\"{o}thlisberger, David},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Embedding Moose Facilities Directly in IDEs}},
url = {http://scg.unibe.ch/archive/papers/Roet08gMooseFacilitiesInIDE.pdf},
year = {2008}
}
@phdthesis{gaelli_modeling_2006,
abstract = {One of the oldest techniques to explain abstract$\backslash$nconcepts is to provide concrete examples. By$\backslash$nexplaining an abstract concept with a concrete$\backslash$nexample people make sure that the concept is$\backslash$nunderstood and remembered. Examples in software can$\backslash$nbe used both to test the software and to illustrate$\backslash$nits functionality. Object-oriented programs are$\backslash$nbuilt around the concepts of classes, methods and$\backslash$nvariables, where methods are the atoms of the$\backslash$nfunctionality. But the meta-models of$\backslash$nobject-oriented languages do not allow developers to$\backslash$nassociate runnable and composable examples with$\backslash$nthese concepts and particularly not with methods.$\backslash$nUnit tests on the other hand, assure the quality of$\backslash$nthe units under test and document them. Not being$\backslash$nintegrated into the language, unit tests are not$\backslash$nlinked explicitly to their units under test which$\backslash$nmakes it unnecessarily dif ficult to use them for$\backslash$ndocumenting, typing and debugging software. In$\backslash$naddition they are not composable making it hard to$\backslash$ndevelop higher level test scenarios in parallel with$\backslash$nhigher level objects. In this thesis we analyze unit$\backslash$ntests to learn about implicit dependencies among$\backslash$ntests and from tests to the methods under test. We$\backslash$ndevelop a technique to partially order unit tests in$\backslash$nterms of their covered methods, which reveals$\backslash$npossible redundancies due to the lack of$\backslash$ncomposability. We show how partial orders can be$\backslash$nused to debug and to comprehend software. We then$\backslash$ndevelop a taxonomy based on several case studies$\backslash$nrevealing that a high fraction of unit tests already$\backslash$nimplicitly focuses on single methods. We show that$\backslash$nthe rest of the tests can be decomposed into$\backslash$ncommands focusing on single methods. We build a$\backslash$nmeta-model based on our findings of analyzing test$\backslash$ninterdependencies which establishes how tests can be$\backslash$nexplicitly linked to their method under test and how$\backslash$nthey can be composed to form higher-level test$\backslash$nscenarios. We explain how the problems of missing$\backslash$nlinks between tests and units under test are solved$\backslash$nusing our meta-model. Furthermore, we implemented$\backslash$nthe meta-model and a first user interface on top of$\backslash$nit to give first evidence of how our model supports$\backslash$nthe developer.},
author = {Gaelli, Markus},
keywords = {Squeak,scg-pub skip-doi scg-phd gaelli jb07 fb06 snf06},
mendeley-tags = {Squeak},
school = {Citeseer},
title = {{Modeling Examples to Test and Understand Software}},
url = {http://scg.unibe.ch/archive/phd/gaelli-phd.pdf},
year = {2006}
}
@article{ducasse_supporting_2002,
author = {Ducasse, St\'{e}phane and Wuyts, Roel and Others},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Supporting Objects as An Anthropomorphic View at Computation or Why Smalltalk for Teaching Objects?}},
year = {2002}
}
@article{Abdeen2009,
abstract = {To cope with the complexity of large object-oriented software systems, developers organize classes into subsystems using the concepts of module or package. Such modular structure helps software systems to evolve when facing new requirements. The organization of classes into packages and/or subsystems represents the software modularization. the software modularization usually follows interrelationships between classes. Ideally, packages should to be loosely coupled and cohesive to a certain extent. However, Studies show that as software evolves to meet requirements and environment changes, the software modularization gradually drifts and looses quality. As a consequence, the software modularization must be maintained. It is thus important to understand, to assess and to optimize the organization of packages and their relationships. Our claim is that the maintenance of large and complex software modularizations needs approaches that help in: (1) understanding package shapes and relationships; (2) assessing the quality of a modularization, as well as the quality of a single package within a given modularization; (3) optimizing the quality of an existing modulariza- tion. In this thesis, we concentrate on three research fields: software visualizations, metrics and algorithms. At first, we define two visualizations that help maintainers: (1) to understand packages structure, usage and relationships; (2) to spot patterns; and (3) to identify misplaced classes and structural anomalies. In addition to visual- izations, we define a suite of metrics that help in assessing the package design quality (i.e., package cohesion and coupling). We also define metrics that assess the quality of a collection of inter-dependent packages from different view points, such as the degree of package coupling and cycles. Finally, we define a search-based algorithm that automatically reduces package coupling and cycles only by moving classes over existing packages. Our optimization approach takes explicitly into account the origi- nal class organization and package structure. It also allows maintainers to control the optimization process by specifying: (1) the maximal number of classes that may change their packages; (2) the classes that are candidate for moving and the classes that should not; (3) the packages that are candidate for restructuring and the packages that should not; and (4) the maximal number of classes that a given package can entail. The approaches presented in this thesis have been applied to real large object- oriented software systems. The results we obtained demonstrate the usefulness of our visualizations and metrics; and the effectiveness of our optimization algorithm.},
author = {Abdeen, Hani},
keywords = {Squeak},
mendeley-tags = {Squeak},
title = {{Visualizing , Assessing and Architectural Elements}},
url = {http://hal.inria.fr/tel-00498389/},
year = {2009}
}
